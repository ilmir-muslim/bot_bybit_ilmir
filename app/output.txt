===== ./notifier.py =====
import requests
from .config import TELEGRAM_BOT_TOKEN, TELEGRAM_BOT_TOKEN_TRADES, TELEGRAM_USER_ID

def send_telegram_message(message: str, buy_sell: bool = False):
    if buy_sell:
        url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN_TRADES}/sendMessage"
    else:
        url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"

    payload = {
        "chat_id": TELEGRAM_USER_ID,
        "text": message
    }
    try:
        response = requests.post(url, json=payload)
        response.raise_for_status()
    except Exception as e:
        print(f"[TELEGRAM ERROR] {e}")
        


===== ./strategies/neural_network/model.py =====
import os
os.environ["TF_CPP_MIN_LOG_LEVEL"] = "3"
os.environ["CUDA_VISIBLE_DEVICES"] = "-1"
import tensorflow as tf
import numpy as np
from sklearn.preprocessing import MinMaxScaler

class NeuralPredictor:
    def __init__(
        self,
        sequence_length: int = 20,
        features: int = 5,
        prediction_steps: int = 3
    ):
        self.sequence_length = sequence_length
        self.features = features
        self.prediction_steps = prediction_steps
        self.scaler = MinMaxScaler(feature_range=(0, 1))
        self.model = self.build_model()
        
    def build_model(self) -> tf.keras.Model:
        """–°–æ–∑–¥–∞–µ—Ç LSTM –º–æ–¥–µ–ª—å –¥–ª—è –ø—Ä–æ–≥–Ω–æ–∑–∏—Ä–æ–≤–∞–Ω–∏—è —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º —É–∫–∞–∑–∞–Ω–∏–µ–º input_shape"""
            
        model = tf.keras.Sequential()
        
        # –î–æ–±–∞–≤–ª—è–µ–º Input —Å–ª–æ–π –≤–º–µ—Å—Ç–æ —É–∫–∞–∑–∞–Ω–∏—è input_shape –≤ LSTM
        model.add(tf.keras.layers.Input(
            shape=(self.sequence_length, self.features),
            name="input_layer"
        ))
        
        model.add(tf.keras.layers.LSTM(
            128, 
            return_sequences=True,
            name="lstm_1"
        ))
        model.add(tf.keras.layers.Dropout(0.3))
        model.add(tf.keras.layers.LSTM(
            64, 
            return_sequences=False,
            name="lstm_2"
        ))
        model.add(tf.keras.layers.Dropout(0.3))
        model.add(tf.keras.layers.Dense(32, activation='relu', name="dense_1"))
        model.add(tf.keras.layers.Dense(self.prediction_steps, name="output"))
        
        model.compile(optimizer='adam', loss='mse')
        return model
    
    # –û—Å—Ç–∞–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
    def prepare_data(self, candles):
        """–ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è/–ø—Ä–æ–≥–Ω–æ–∑–∞"""
        data = np.array([
            [c['open'], c['high'], c['low'], c['close'], c['volume']] 
            for c in candles
        ])
        return self.scaler.fit_transform(data)
    
    def train(self, data, epochs=50, batch_size=32):
        """–û–±—É—á–∞–µ—Ç –º–æ–¥–µ–ª—å –Ω–∞ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö"""
        if len(data) < self.sequence_length + self.prediction_steps:
            raise ValueError("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±—É—á–µ–Ω–∏—è")
            
        X, y = [], []
        for i in range(len(data) - self.sequence_length - self.prediction_steps):
            X.append(data[i:i+self.sequence_length])
            y.append(data[i+self.sequence_length:i+self.sequence_length+self.prediction_steps, 3])
        
        X = np.array(X)
        y = np.array(y)
        
        return self.model.fit(X, y, epochs=epochs, batch_size=batch_size, validation_split=0.1)
    
    def predict(self, data):
        """–î–µ–ª–∞–µ—Ç –ø—Ä–æ–≥–Ω–æ–∑ –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –¥–∞–Ω–Ω—ã—Ö"""
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
        if len(data) < self.sequence_length:
            raise ValueError(f"–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö. –¢—Ä–µ–±—É–µ—Ç—Å—è: {self.sequence_length}, –ø–æ–ª—É—á–µ–Ω–æ: {len(data)}")
        
        # –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
        scaled_data = self.scaler.transform(data)
        
        # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –¥–ª—è –ø—Ä–æ–≥–Ω–æ–∑–∞
        sequence = scaled_data[-self.sequence_length:]
        sequence = np.array([sequence])  # –î–æ–±–∞–≤–ª—è–µ–º —Ä–∞–∑–º–µ—Ä–Ω–æ—Å—Ç—å –±–∞—Ç—á–∞
        
        # –ü–æ–ª—É—á–µ–Ω–∏–µ –ø—Ä–æ–≥–Ω–æ–∑–∞
        prediction = self.model.predict(sequence)
        
        # –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π –º–∞—Å—Å–∏–≤ —Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–≥–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è
        # –§–æ—Ä–º–∞: (–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ–≥–Ω–æ–∑–æ–≤, –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–∏–∑–Ω–∞–∫–æ–≤)
        dummy = np.zeros((prediction.shape[1], self.features))
        
        # –ü–æ–º–µ—â–∞–µ–º –ø—Ä–æ–≥–Ω–æ–∑—ã –≤ —Å—Ç–æ–ª–±–µ—Ü –∑–∞–∫—Ä—ã—Ç–∏—è (–∏–Ω–¥–µ–∫—Å 3)
        dummy[:, 3] = prediction[0]
        
        # –ü—Ä–∏–º–µ–Ω—è–µ–º –æ–±—Ä–∞—Ç–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ
        unscaled = self.scaler.inverse_transform(dummy)
        
        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–æ–ª—å–∫–æ –ø—Ä–æ–≥–Ω–æ–∑—ã –∑–∞–∫—Ä—ã—Ç–∏—è
        return unscaled[:, 3]
    
    def save(self, path):
        """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –º–æ–¥–µ–ª—å –≤ —Å–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–º —Ñ–æ—Ä–º–∞—Ç–µ"""
        self.model.save(f"{path}.keras")
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã scaler –æ—Ç–¥–µ–ª—å–Ω–æ
        np.savez(f"{path}_scaler.npz", scale=self.scaler.scale_, min=self.scaler.min_)
    
    def load(self, path):
        # –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ –ø—É—Ç—å –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –ª–∏—à–Ω–∏—Ö —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–π
        base_path = path.replace('.keras', '')
        
        model_path = f"{base_path}.keras"
        scaler_path = f"{base_path}_scaler.npz"
        
        if not os.path.exists(model_path) or not os.path.exists(scaler_path):
            available_files = os.listdir(os.path.dirname(base_path))
            raise FileNotFoundError(
                f"–ú–æ–¥–µ–ª—å –∏–ª–∏ —Å–∫–∞–ª–µ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω—ã:\n"
                f"‚Ä¢ {model_path}\n"
                f"‚Ä¢ {scaler_path}\n"
                f"–î–æ—Å—Ç—É–ø–Ω—ã–µ —Ñ–∞–π–ª—ã: {available_files}"
            )
        
        self.model = tf.keras.models.load_model(model_path)
        scaler_data = np.load(scaler_path)
        self.scaler.scale_ = scaler_data['scale']
        self.scaler.min_ = scaler_data['min']

===== ./strategies/neural_network/trainer.py =====
import argparse
import os
from .model import NeuralPredictor

def main():
    from app.services.bybit_service import BybitService
    
    parser = argparse.ArgumentParser(description='–û–±—É—á–µ–Ω–∏–µ —Ç–æ—Ä–≥–æ–≤–æ–π –Ω–µ–π—Ä–æ—Å–µ—Ç–∏')
    parser.add_argument('--symbol', type=str, default='SOLUSDT', help='–¢–æ—Ä–≥–æ–≤—ã–π —Å–∏–º–≤–æ–ª')
    parser.add_argument('--interval', type=str, default='5', help='5-–º–∏–Ω—É—Ç–Ω—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª')
    parser.add_argument('--epochs', type=int, default=200, help='–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ø–æ—Ö –æ–±—É—á–µ–Ω–∏—è')
    parser.add_argument('--model_path', type=str, default='models/neural_model.keras', help='–ü—É—Ç—å –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –º–æ–¥–µ–ª–∏')
    args = parser.parse_args()

    os.makedirs(os.path.dirname(args.model_path), exist_ok=True)
    
    bybit = BybitService()
    candles = bybit.get_candles(args.symbol, args.interval, limit=10000)    
    
    # –£–º–µ–Ω—å—à–∏–ª–∏ –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –ø–æ—Ä–æ–≥ –¥–∞–Ω–Ω—ã—Ö
    if not candles or len(candles) < 180:
        print(f"‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ–±—É—á–µ–Ω–∏—è ({len(candles) if candles else 0} < 180)")
        return
    
    # –£–º–µ–Ω—å—à–∏–ª–∏ –¥–ª–∏–Ω—É –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    predictor = NeuralPredictor(
        sequence_length=30,  # –ë—ã–ª–æ 60
        prediction_steps=3
    )
    data = predictor.prepare_data(candles)
    predictor.train(data, epochs=args.epochs)
    
    model_base_path = args.model_path.replace('.keras', '')
    predictor.save(model_base_path)
    print(f"‚úÖ –ú–æ–¥–µ–ª—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –∫–∞–∫: {model_base_path}.keras")
    

if __name__ == "__main__":
    main()

===== ./strategies/neural_network/__init__.py =====
# app/strategies/neural_network/__init__.py
from .model import NeuralPredictor


__all__ = ['NeuralPredictor']

===== ./strategies/neural_strategy.py =====
import numpy as np
import time
from app.strategies.base import Strategy
from app.strategies.ma_crossover import MovingAverageStrategy
from app.utils.log_helper import log_maker
from app.strategies.neural_network.model import NeuralPredictor

class NeuralStrategy(Strategy):
    def __init__(
        self, 
        symbol: str, 
        bybit_service, 
        model_path: str = "models/neural_model",
        base_threshold: float = 0.25,
        volatility_factor: float = 0.5,
        rotator=None,
        trading_system=None,
        interval: str = "5"
    ):
        coin = symbol.replace('USDT', '')
        self.symbol = symbol
        self.bybit = bybit_service
        self.position_coin = coin
        
        model_base_path = f"models/{coin}_neural_model"
        
        self.base_threshold = base_threshold
        self.volatility_factor = volatility_factor
        self.predictor = NeuralPredictor(
            sequence_length=30,  
            prediction_steps=3
        )
        self.rotator = rotator
        self.trading_system = trading_system
        self.interval = interval 
        
        try:
            self.predictor.load(model_base_path)
            log_maker(f"üß† –ù–µ–π—Ä–æ—Å–µ—Ç–µ–≤–∞—è –º–æ–¥–µ–ª—å –∑–∞–≥—Ä—É–∂–µ–Ω–∞ –∏–∑ {model_base_path}")
            log_maker(f"  ‚Ä¢ –î–ª–∏–Ω–∞ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏: {self.predictor.sequence_length} —Å–≤–µ—á–µ–π")
            log_maker(f"  ‚Ä¢ –ü—Ä–æ–≥–Ω–æ–∑ –Ω–∞ —à–∞–≥–æ–≤: {self.predictor.prediction_steps}")
            log_maker(f"  ‚Ä¢ –ë–∞–∑–æ–≤—ã–π –ø–æ—Ä–æ–≥: {base_threshold:.1f}%, –ö–æ—ç—Ñ. –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç–∏: {volatility_factor}")
        except Exception as e:
            log_maker(f"üî• –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏: {e}")
            # Fallback –Ω–∞ MA —Å—Ç—Ä–∞—Ç–µ–≥–∏—é
            self.strategy = MovingAverageStrategy(
                symbol, 
                "3", 
                rotator=rotator,
                trading_system=trading_system
            )
        
        self.min_order_qty = bybit_service.get_min_order_qty(symbol)
        log_maker(f"  ‚Ä¢ –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –ª–æ—Ç: {self.min_order_qty}")
        self.last_candle_time = 0

    def calculate_volatility(self, candles: list, lookback: int = 20) -> float:
        ranges = []
        for i in range(-lookback, 0):
            candle = candles[i]
            candle_range = (candle['high'] - candle['low']) / candle['close']
            ranges.append(candle_range)
        return np.mean(ranges) * 100

    def should_trade(self, candles: list) -> str:
        # –£–±—Ä–∞–ª–∏ —Ñ–∏–ª—å—Ç—Ä –æ–±—ä–µ–º–∞ —Å–≤–µ—á–∏
        # –°–æ—Ö—Ä–∞–Ω–∏–ª–∏ –ø—Ä–æ–≤–µ—Ä–∫—É –∫–æ–Ω—Ñ–ª–∏–∫—Ç–∞ –º–æ–Ω–µ—Ç
        current_coin = self.symbol.replace('USDT', '')
        if current_coin != self.position_coin:
            log_maker(f"‚ö†Ô∏è –ö–æ–Ω—Ñ–ª–∏–∫—Ç –º–æ–Ω–µ—Ç: —Å—Ç—Ä–∞—Ç–µ–≥–∏—è {current_coin} vs —Å–æ—Å—Ç–æ—è–Ω–∏–µ {self.position_coin}")
            return None
            
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π –¥–ª–∏–Ω—ã –¥–∞–Ω–Ω—ã—Ö
        if len(candles) < self.predictor.sequence_length:
            log_maker(f"üß†‚ö†Ô∏è –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö: {len(candles)} < {self.predictor.sequence_length}")
            return None
            
        try:
            # –û—Å–Ω–æ–≤–Ω–æ–π –±–ª–æ–∫ –∞–Ω–∞–ª–∏–∑–∞
            start_time = time.time()
            current_price = self.bybit.get_reliable_price(self.symbol)
            if current_price is None:
                log_maker("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É")
                return None
                
            volatility = self.calculate_volatility(candles)
            adaptive_threshold = self.base_threshold + (volatility * self.volatility_factor)
            buy_threshold = adaptive_threshold
            sell_threshold = -adaptive_threshold
            
            data = np.array([
                [c['open'], c['high'], c['low'], c['close'], c['volume']] 
                for c in candles[-self.predictor.sequence_length:]
            ])
            
            predictions = self.predictor.predict(data)
            predicted_changes = []
            prediction_details = []
            
            for i, pred_price in enumerate(predictions, 1):
                change = (pred_price - current_price) / current_price * 100
                predicted_changes.append(change)
                prediction_details.append({
                    "step": i,
                    "price": pred_price,
                    "change_pct": change
                })
            
            max_change = max(predicted_changes, key=abs) if predicted_changes else 0
            signal = None
            reason = ""
            
            if max_change > buy_threshold:
                signal = "BUY"
                reason = f"—Ä–æ—Å—Ç +{max_change:.2f}% > –ø–æ—Ä–æ–≥–∞ {buy_threshold:.2f}%"
            elif max_change < sell_threshold:
                signal = "SELL"
                reason = f"–ø–∞–¥–µ–Ω–∏–µ {max_change:.2f}% < –ø–æ—Ä–æ–≥–∞ {sell_threshold:.2f}%"
            
            predictions_str = "\n ".join(
                [f"{p['step']} —à–∞–≥: {p['change_pct']:+.2f}%" 
                for p in prediction_details]
            )
            
            # –§–æ—Ä–º–∏—Ä—É–µ–º –ª–æ–≥ –í–°–ï–ì–î–ê
            analysis_time = time.time() - start_time
            log_text = (
                f"üß† –ê–Ω–∞–ª–∏–∑ {self.symbol} | –¶–µ–Ω–∞: {current_price:.4f} | –í–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å: {volatility:.2f}%\n"
                f"  ‚Ä¢ –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –ø–æ—Ä–æ–≥–∏: BUY > {buy_threshold:.2f}%, SELL < {sell_threshold:.2f}%\n"
                f"  ‚Ä¢ –ü—Ä–æ–≥–Ω–æ–∑—ã: {predictions_str}\n"
                f"  ‚Ä¢ –ú–∞–∫—Å. –∏–∑–º–µ–Ω–µ–Ω–∏–µ: {max_change:+.2f}% ({reason})\n"
                f"  ‚Ä¢ –†–µ—à–µ–Ω–∏–µ: {'–°–ò–ì–ù–ê–õ ' + signal if signal else '–ù–ï–¢ –°–ò–ì–ù–ê–õ–ê'}\n"
                f"  ‚Ä¢ –í—Ä–µ–º—è –∞–Ω–∞–ª–∏–∑–∞: {analysis_time:.2f} —Å–µ–∫"
            )
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–∞–ª–∞–Ω—Å –¥–ª—è —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π
            coin = self.symbol.replace('USDT', '')
            position_qty = self.bybit.get_balance(coin)
            
            # –î–æ–±–∞–≤–ª—è–µ–º —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –ø—Ä–æ–ø—É—Å–∫—É (–Ω–µ –±–ª–æ–∫–∏—Ä—É–µ–º —Å–∏–≥–Ω–∞–ª)
            if signal == "SELL" and position_qty < self.min_order_qty:
                log_text += f"\n  ‚Ä¢ üß†‚è© –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è: –ü—Ä–æ–ø—É—Å–∫ SELL (–ø–æ–∑–∏—Ü–∏—è {position_qty} < {self.min_order_qty})"
                
            if signal == "BUY" and position_qty >= self.min_order_qty:
                log_text += f"\n  ‚Ä¢ üß†‚è© –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è: –ü—Ä–æ–ø—É—Å–∫ BUY (—É–∂–µ –µ—Å—Ç—å –ø–æ–∑–∏—Ü–∏—è {position_qty})"
                
            log_maker(log_text)
            
            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å–∏–≥–Ω–∞–ª –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç –ø–æ–∑–∏—Ü–∏–∏
            return signal
                
        except Exception as e:
            log_maker(f"üß†‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –Ω–µ–π—Ä–æ—Å–µ—Ç–∏: {str(e)}")
            import traceback
            log_maker(f"–¢—Ä–µ–π—Å–±–µ–∫: {traceback.format_exc()}")
            return None

    def execute_trade(self, action: str, executor):
        if action == "BUY":
            log_maker(f"üß†üü¢ –ò—Å–ø–æ–ª–Ω—è—é BUY –ø–æ {self.symbol}")
            executor.execute_buy(trading_system=self.trading_system)
        elif action == "SELL":
            log_maker(f"üß†üî¥ –ò—Å–ø–æ–ª–Ω—è—é SELL –ø–æ {self.symbol}")
            executor.execute_sell(strategy=self)

===== ./strategies/base.py =====
from abc import ABC, abstractmethod
from typing import Optional


class Strategy(ABC):
    """–ë–∞–∑–æ–≤—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è —Ç–æ—Ä–≥–æ–≤–æ–π —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏."""

    @abstractmethod
    def should_trade(self, prices: list[float]) -> Optional[str]:
        """–†–µ—à–∞–µ—Ç, —Å—Ç–æ–∏—Ç –ª–∏ –ø–æ–∫—É–ø–∞—Ç—å –∏–ª–∏ –ø—Ä–æ–¥–∞–≤–∞—Ç—å.
        :param prices: —Å–ø–∏—Å–æ–∫ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö —Ü–µ–Ω
        :return: "BUY", "SELL" –∏–ª–∏ None
        """
        pass


===== ./strategies/__init__.py =====
from .ma_crossover import MovingAverageStrategy
from .neural_strategy import NeuralStrategy

__all__ = ['MovingAverageStrategy', 'NeuralStrategy']


===== ./strategies/balance_snapshots.json =====
{
    "today": {
        "balance": 10.57738454,
        "timestamp": "2025-06-25 00:00:00"
    },
    "week": {
        "balance": 10.059597216,
        "timestamp": "2025-06-23 00:00:00"
    },
    "month": {
        "balance": 10.059597216,
        "timestamp": "2025-06-01 00:00:00"
    },
    "last_update": "2025-06-25 01:12:42"
}

===== ./strategies/ma_crossover.py =====
import time
import numpy as np
from typing import List, Dict, Optional
from app.indicators.market_grades import grade_atr, grade_ema_diff, grade_slope, grade_volatility
from app.utils.get_profit import ProfitCalculator
from app.utils.log_helper import log_maker
from app.services.bybit_service import BybitService

class MovingAverageStrategy:
    def __init__(
        self,
        symbol: str,
        interval: str = "3",
        short_window: int = 8,
        medium_window: int = 21,
        long_window: int = 50,
        initial_data_limit: int = 500,
        rotator=None,  # –î–ª—è —Ä–æ—Ç–∞—Ç–æ—Ä–∞ –º–æ–Ω–µ—Ç
        trading_system=None  # –î–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏—è–º–∏
    ):
        self.symbol = symbol
        self.interval = interval
        self.short_window = short_window
        self.medium_window = medium_window
        self.long_window = long_window
        self.initial_data_limit = initial_data_limit
        self.bybit = BybitService()
        self.rotator = rotator  # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–æ—Ç–∞—Ç–æ—Ä
        self.trading_system = trading_system  # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Å—ã–ª–∫—É –Ω–∞ —Ç–æ—Ä–≥–æ–≤—É—é —Å–∏—Å—Ç–µ–º—É

        # –°–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏
        self.position_qty = 0.0
        self.avg_buy_price = 0.0
        self.last_action = "NONE"
        self.max_price_since_buy = None
        self.last_trade_time = time.time()

        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
        self.trade_opportunities = 0
        self.executed_trades = 0

        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è —á–µ—Ä–µ–∑ API
        self._init_state_from_api()

        # ===== –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–´–ï –ü–ê–†–ê–ú–ï–¢–†–´ –î–õ–Ø –ú–ï–ù–ï–ï –ê–ì–†–ï–°–°–ò–í–ù–û–ô –°–¢–†–ê–¢–ï–ì–ò–ò =====
        # –ê–¥–∞–ø—Ç–∏–≤–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
        self.adaptive_params = True
        self.base_min_cross = 0.0005  # –£–≤–µ–ª–∏—á–µ–Ω —Å 0.0002
        self.base_min_slope = 0.00001  # –£–≤–µ–ª–∏—á–µ–Ω —Å 0.000005

        # –†–∏—Å–∫-–º–µ–Ω–µ–¥–∂–º–µ–Ω—Ç
        self.base_min_profit = 0.0080  # –£–≤–µ–ª–∏—á–µ–Ω —Å 0.0050
        self.max_loss = 0.0075         # –£–º–µ–Ω—å—à–µ–Ω —Å 0.01
        self.emergency_stop = -0.006   # –≠–∫—Å—Ç—Ä–µ–Ω–Ω—ã–π —Å—Ç–æ–ø –ø—Ä–∏ -0.6%

        # –§–∏–ª—å—Ç—Ä—ã –≤—Ö–æ–¥–∞
        self.min_volume_ratio = 0.8    # –£–≤–µ–ª–∏—á–µ–Ω —Å 0.4
        self.adaptive_volume_ratio = 0.05  # –£–≤–µ–ª–∏—á–µ–Ω —Å 0.02
        self.volume_lookback = 20      # –£–≤–µ–ª–∏—á–µ–Ω —Å 15

        # –í—ã—Ö–æ–¥ –∏–∑ –ø–æ–∑–∏—Ü–∏–∏
        self.trailing_stop_activation = 0.020  # –£–≤–µ–ª–∏—á–µ–Ω —Å 0.015
        self.trailing_stop_distance = 0.005    # –£–º–µ–Ω—å—à–µ–Ω —Å 0.006

        # –ß–∞—Å—Ç–∏—á–Ω–æ–µ –≤–∑—è—Ç–∏–µ –ø—Ä–∏–±—ã–ª–∏ (–º–µ–Ω–µ–µ –∞–≥—Ä–µ—Å—Å–∏–≤–Ω–æ–µ)
        self.partial_profit_levels = [0.004, 0.008, 0.012]  # –£–≤–µ–ª–∏—á–µ–Ω—ã
        self.partial_profit_pcts = [0.2, 0.3, 0.5]          # –£–º–µ–Ω—å—à–µ–Ω—ã
        self.partial_taken = [False, False, False]
        
        # –ß–∞—Å—Ç–∏—á–Ω—ã–π –≤—ã—Ö–æ–¥ –ø—Ä–∏ —É–±—ã—Ç–∫–∞—Ö
        self.partial_exit_level = -0.0025  # –£–≤–µ–ª–∏—á–µ–Ω —Å -0.003
        self.partial_exit_pct = 0.3        # –£–º–µ–Ω—å—à–µ–Ω —Å 0.5
        self.partial_exit_taken = False

        # –ó–∞—â–∏—Ç–∞ –æ—Ç –ø—Ä–µ–∂–¥–µ–≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ –≤—ã—Ö–æ–¥–∞
        self.min_hold_time = 30 * 60  # –£–≤–µ–ª–∏—á–µ–Ω —Å 15 –¥–æ 30 –º–∏–Ω—É—Ç

        # –í—ã—Ö–æ–¥ –ø–æ —Ñ–ª—ç—Ç—É
        self.flat_volatility_threshold = 0.0008  # –£–≤–µ–ª–∏—á–µ–Ω —Å 0.0006
        self.flat_max_duration = 180
        self.flat_counter = 0
        self.flat_max_no_growth = 25  # –£–≤–µ–ª–∏—á–µ–Ω–æ —Å 15 –¥–æ 25
        self.flat_exit_profit = 0.0
        self.min_hold_time_for_flat = 3600  # –£–≤–µ–ª–∏—á–µ–Ω —Å 30 –¥–æ 60 –º–∏–Ω—É—Ç
        
        # –§–∏–ª—å—Ç—Ä—ã –ø–æ RSI –∏ —Ç—Ä–µ–Ω–¥—É
        self.rsi_overbought_threshold = 65  # –£–º–µ–Ω—å—à–µ–Ω —Å 68
        self.min_risk_reward_ratio = 2.5    # –£–≤–µ–ª–∏—á–µ–Ω —Å 1.8

        self.min_avg_price = 0.01  # –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –¥–æ–ø—É—Å—Ç–∏–º–∞—è —Ü–µ–Ω–∞ –ø–æ–∫—É–ø–∫–∏

        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã
        self.require_confirmation = True    # –¢—Ä–µ–±–æ–≤–∞—Ç—å –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —Å–∏–≥–Ω–∞–ª–∞
        self.confirmation_period = 3        # –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–≤–µ—á–µ–π –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
        self.required_trend_strength = 4    # –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å–∏–ª–∞ —Ç—Ä–µ–Ω–¥–∞ –¥–ª—è –≤—Ö–æ–¥–∞

        # ===== –ö–û–ù–ï–¶ –ü–ê–†–ê–ú–ï–¢–†–û–í =====

        # –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        self.prev_short_ema = None
        self.prev_medium_ema = None
        self.prev_long_ema = None
        self.ma_crossed_down = False
        self.ema_history = []
        self.last_trade_price = 0.0
        self.current_atr = 0.0
        self.current_short_ema = 0.0
        self.current_medium_ema = 0.0
        self.last_candle_time = None
        self.pending_signal = None
        self.signal_confirmation_count = 0

        # –ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö
        self._load_initial_data()

    def _load_initial_data(self):
        log_maker(
            f"‚è≥ –ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö ({self.initial_data_limit} —Å–≤–µ—á–µ–π)..."
        )
        try:
            historical_candles = self.bybit.get_candles(
                self.symbol, interval=self.interval, limit=self.initial_data_limit
            )

            if historical_candles and len(historical_candles) > 50:
                closes = [c["close"] for c in historical_candles]
                self.prev_short_ema = self._calc_ema(closes, self.short_window)
                self.prev_medium_ema = self._calc_ema(closes, self.medium_window)
                self.prev_long_ema = self._calc_ema(closes, self.long_window)

                log_maker(
                    f"üìä –ò—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–µ EMA –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã:\n"
                    f"  Short ({self.short_window}): {self.prev_short_ema:.6f}\n"
                    f"  Medium ({self.medium_window}): {self.prev_medium_ema:.6f}\n"
                    f"  Long ({self.long_window}): {self.prev_long_ema:.6f}"
                )
            else:
                log_maker(
                    "‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ EMA"
                )
        except Exception as e:
            log_maker(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö: {e}")

    def _init_state_from_api(self):
        log_maker("\n\n‚öôÔ∏è –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è —á–µ—Ä–µ–∑ API...")
        try:
            coin = self.symbol.replace("USDT", "")
            actual_balance = self.bybit.get_balance(coin)
            self.position_qty = actual_balance

            # –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ –æ—Ä–¥–µ—Ä–∞ –∏–∑ API
            orders = self.bybit.get_filled_orders(self.symbol, limit=20)
            
            # –ï—Å–ª–∏ –µ—Å—Ç—å –æ—Ä–¥–µ—Ä–∞, –∏—â–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π BUY
            last_buy_price = None
            if orders:
                for order in orders:
                    if order["side"].upper() == "BUY":
                        last_buy_price = float(order.get("avgPrice", 0.0))
                        break
            
            # –ï—Å–ª–∏ –Ω–∞—à–ª–∏ —Ü–µ–Ω—É –ø–æ–∫—É–ø–∫–∏
            if last_buy_price:
                self.avg_buy_price = last_buy_price
                log_maker(f"‚öôÔ∏è –¶–µ–Ω–∞ –ø–æ–∫—É–ø–∫–∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞: {self.avg_buy_price:.6f}")
            else:
                # –ï—Å–ª–∏ –ø–æ–∑–∏—Ü–∏—è –µ—Å—Ç—å, –Ω–æ –Ω–µ—Ç –∏—Å—Ç–æ—Ä–∏–∏ –ø–æ–∫—É–ø–æ–∫
                if actual_balance > 0:
                    current_price = self.bybit.get_reliable_price(self.symbol)
                    self.avg_buy_price = current_price
                    log_maker(f"‚öôÔ∏è –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ —Ç–µ–∫—É—â–∞—è —Ü–µ–Ω–∞ –∫–∞–∫ —Ü–µ–Ω–∞ –ø–æ–∫—É–ø–∫–∏: {current_price:.6f}")
                else:
                    self.avg_buy_price = 0.0
                    
        except Exception as e:
            log_maker(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∏–∑ API: {e}")
            self.position_qty = 0
            self.avg_buy_price = 0.0
            
    def _record_trade(self, side: str):
        try:
            order = self.bybit.get_last_filled_order(self.symbol)
            if not order:
                log_maker("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –æ—Ä–¥–µ—Ä–∞ –∏–∑ API")
                return

            actual_price = float(order["avg_price"])
            self.last_trade_price = actual_price
            actual_qty = float(order["qty"])
            usdt_qty = float(order["cumExecValue"])
            coin_qty = float(order["cumExecQty"])
            actual_side = order["side"].upper()

            # –î–ª—è –ø–æ–∫—É–ø–∫–∏
            if actual_side == "BUY":
                if self.position_qty > 0:
                    total_cost = (self.avg_buy_price * self.position_qty) + (
                        actual_price * actual_qty
                    )
                    self.position_qty += actual_qty
                    self.avg_buy_price = total_cost / self.position_qty
                else:
                    self.position_qty = actual_qty
                    self.avg_buy_price = actual_price
                
                # –°–±—Ä–æ—Å —Ñ–ª–∞–≥–æ–≤ –ø—Ä–∏ –Ω–æ–≤–æ–π –ø–æ–∫—É–ø–∫–µ
                self.partial_exit_taken = False
                self.max_price_since_buy = actual_price

            # –î–ª—è –ø—Ä–æ–¥–∞–∂–∏
            elif actual_side == "SELL":
                if self.position_qty > 0:
                    sell_qty = min(actual_qty, self.position_qty)
                    self.position_qty -= sell_qty
                    if self.position_qty <= 0:
                        self.avg_buy_price = 0.0
                        self.max_price_since_buy = None
                        # –°–±—Ä–æ—Å —Ñ–ª–∞–≥–æ–≤ –ø—Ä–∏ –ø–æ–ª–Ω–æ–π –ø—Ä–æ–¥–∞–∂–µ
                        self.partial_exit_taken = False
            
            # –î–ª—è —á–∞—Å—Ç–∏—á–Ω–æ–π –ø—Ä–æ–¥–∞–∂–∏
            elif actual_side == "SELL_PARTIAL":
                if self.position_qty > 0:
                    sell_qty = min(actual_qty, self.position_qty)
                    self.position_qty -= sell_qty
                    # –ù–µ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º avg_buy_price –ø—Ä–∏ —á–∞—Å—Ç–∏—á–Ω–æ–π –ø—Ä–æ–¥–∞–∂–µ
                    if self.position_qty <= 0:
                        self.avg_buy_price = 0.0
                        self.max_price_since_buy = None
            
            coin = self.symbol.replace("USDT", "")
            amount = coin_qty
            log_maker(
                f"üìù –°–¥–µ–ª–∫–∞ –∑–∞–ø–∏—Å–∞–Ω–∞: {actual_side} {amount} {coin} –ø–æ —Ü–µ–Ω–µ {actual_price:.6f}. "
                f"–¢–µ–∫—É—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ: {self.position_qty:.6f}"
            )
        except Exception as e:
            log_maker(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø–∏—Å–∏ —Å–¥–µ–ª–∫–∏: {e}")
            self._init_state_from_api()

    def _calculate_atr(self, candles: List[Dict], window: int = 14) -> float:
        if len(candles) < 2:
            return 0.0

        trs = []
        start_idx = max(1, len(candles) - window)

        for i in range(start_idx, len(candles)):
            high = candles[i]["high"]
            low = candles[i]["low"]
            prev_close = candles[i - 1]["close"]
            tr = max(high - low, abs(high - prev_close), abs(low - prev_close))
            trs.append(tr)

        return np.mean(trs[-window:]) if trs else 0.0

    def _calc_ema(self, prices: List[float], window: int) -> float:
        if not prices or len(prices) < window:
            return 0.0
            
        k = 2 / (window + 1)
        ema = prices[0]
        
        for price in prices[1:]:
            ema = price * k + ema * (1 - k)
            
        return ema

    def _get_profit_stats(self) -> dict:
        try:
            calculator = ProfitCalculator(
                symbol=self.symbol, bybit=self.bybit, last_action=self.last_action
            )
            return calculator.get_profit_stats()
        except Exception as e:
            log_maker(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø—Ä–∏–±—ã–ª–∏: {e}")
            return {"today": 0.0, "7_days": 0.0, "30_days": 0.0}
            
    def _check_hourly_trend(self) -> int:
        try:
            hourly_candles = self.bybit.get_candles(
                self.symbol, interval="30", limit=8
            )
            
            if len(hourly_candles) < 5:
                return 0
                
            closes = [c["close"] for c in hourly_candles]
            short_ema = self._calc_ema(closes, 5)
            medium_ema = self._calc_ema(closes, 10)
            
            if short_ema > medium_ema:
                return 1
            elif short_ema < medium_ema:
                return -1
            return 0
        except Exception as e:
            log_maker(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —á–∞—Å–æ–≤–æ–≥–æ —Ç—Ä–µ–Ω–¥–∞: {e}")
            return 0

    def _calculate_rsi(self, closes: List[float], period: int = 14) -> float:
        if len(closes) < period + 1:
            return 50.0

        relevant_closes = closes[-(period+1):]
        deltas = np.diff(relevant_closes)
        
        gains = np.where(deltas > 0, deltas, 0)
        losses = np.where(deltas < 0, -deltas, 0)
        
        avg_gain = np.mean(gains[:period])
        avg_loss = np.mean(losses[:period])
        
        for i in range(period, len(gains)):
            avg_gain = (avg_gain * (period-1) + gains[i]) / period
            avg_loss = (avg_loss * (period-1) + losses[i]) / period
        
        if avg_loss == 0:
            return 100.0 if avg_gain > 0 else 50.0
            
        rs = avg_gain / avg_loss
        rsi = 100.0 - (100.0 / (1.0 + rs))
        return min(max(rsi, 0), 100)

    def should_trade(self, candles: List[Dict]) -> Optional[str]:
        if not candles:
            return None
            
        current_candle = candles[-1]
        current_candle_time = current_candle.get('timestamp')
        
        if not current_candle_time:
            current_candle_time = time.time()
        
        if self.last_candle_time == current_candle_time:
            return None
            
        self.last_candle_time = current_candle_time

        self._init_state_from_api()
        if not candles:
            return None

        self.trade_opportunities += 1

        if len(candles) < 50:
            log_maker(
                "üìäüì≠ –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ (—Ç—Ä–µ–±—É–µ—Ç—Å—è –º–∏–Ω–∏–º—É–º 50 —Å–≤–µ—á–µ–π)"
            )
            return None

        current_price = self.bybit.get_price(self.symbol)
        if not self.bybit.validate_price(current_price, self.symbol):
            log_maker("üö® –¶–µ–Ω–∞ –Ω–µ –ø—Ä–æ—à–ª–∞ –≤–∞–ª–∏–¥–∞—Ü–∏—é! –ó–∞–ø—Ä–æ—Å –Ω–∞–¥–µ–∂–Ω–æ–π —Ü–µ–Ω—ã...")
            current_price = self.bybit.get_reliable_price(self.symbol)

        if current_price is None or not self.bybit.validate_price(
            current_price, self.symbol
        ):
            log_maker("üí∏‚ùå –ù–µ—Ç –¥–æ—Å—Ç–æ–≤–µ—Ä–Ω–æ–π —Ü–µ–Ω—ã, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –∏—Ç–µ—Ä–∞—Ü–∏—é.")
            return None
        
        if (self.position_qty > 0 
            and self.avg_buy_price < self.min_avg_price
            and self.last_action == "BUY"):
            log_maker("‚ö†Ô∏è –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: —Ü–µ–Ω–∞ –ø–æ–∫—É–ø–∫–∏ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞! –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É.")
            self.avg_buy_price = current_price
            self.last_trade_time = time.time()

        candle_low = current_candle['low']
        price_diff = (current_price - candle_low) / candle_low
        if not self.position_qty and price_diff > 0.005:
            log_maker(f"‚è© –ü—Ä–æ–ø—É—Å–∫ BUY: —Ü–µ–Ω–∞ ({current_price}) –¥–∞–ª–µ–∫–æ –æ—Ç –º–∏–Ω–∏–º—É–º–∞ —Å–≤–µ—á–∏ ({candle_low})")
            return None

        closes = [c["close"] for c in candles]
        volumes = [c.get("volume", 0) for c in candles]
        if max(volumes[-self.volume_lookback:]) == 0:
            log_maker("‚ö†Ô∏è –û–±–Ω–∞—Ä—É–∂–µ–Ω –Ω—É–ª–µ–≤–æ–π –æ–±—ä–µ–º, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –∏—Ç–µ—Ä–∞—Ü–∏—é")
            return None

        range_window = 20
        upper_level = max(closes[-range_window:])
        lower_level = min(closes[-range_window:])
        level_delta = (upper_level - lower_level) * 0.02

        short_ema = self._calc_ema(closes, self.short_window)
        medium_ema = self._calc_ema(closes, self.medium_window)
        long_ema = self._calc_ema(closes, self.long_window)

        self.current_short_ema = short_ema
        self.current_medium_ema = medium_ema

        self.ema_history.append(short_ema)
        if len(self.ema_history) > 10:
            self.ema_history.pop(0)

        if len(self.ema_history) >= 3:
            slopes = []
            for i in range(1, 3):
                if self.ema_history[-i - 1] > 0:
                    slope = (
                        (self.ema_history[-i] - self.ema_history[-i - 1])
                        / self.ema_history[-i - 1]
                    ) * 100
                    slopes.append(slope)
            short_ema_slope = np.mean(slopes) if slopes else 0
        else:
            short_ema_slope = (
                ((short_ema - self.prev_short_ema) / self.prev_short_ema) * 100
                if self.prev_short_ema > 0
                else 0
            )

        returns = [np.log(closes[i] / closes[i - 1]) for i in range(1, len(closes))]
        volatility = np.std(returns[-self.long_window :]) if returns else 0.0
        volatility_percent = volatility * 100

        volatility_factor = min(5.0, volatility_percent / 0.05) if volatility_percent > 0 else 1.0

        taker_fee = 0.0018
        min_profit_dynamic = max(
            self.base_min_profit,
            taker_fee * 2 + 0.0003,
            volatility * 1.5,
        )

        atr = self._calculate_atr(candles, window=14)
        self.current_atr = atr

        rsi = self._calculate_rsi(closes)
        if not self.position_qty and rsi > self.rsi_overbought_threshold:
            log_maker(f"‚è© –ü—Ä–æ–ø—É—Å–∫ BUY: RSI {rsi:.2f} > {self.rsi_overbought_threshold} (–ø–µ—Ä–µ–∫—É–ø–ª–µ–Ω–Ω–æ—Å—Ç—å)")
            return None

        if self.adaptive_params:
            adaptive_cross_diff = max(
                self.base_min_cross, min(0.01, volatility_factor * self.base_min_cross)
            )
            adaptive_ema_slope = max(
                self.base_min_slope, min(0.005, volatility_factor * self.base_min_slope)
            )
            adaptive_volume_ratio = max(
                0.01,
                min(1.0, 0.5 / volatility_factor),
            )
            
            if volatility_factor < 0.8:
                adaptive_cross_diff *= 0.7
                adaptive_ema_slope *= 0.6
                adaptive_volume_ratio *= 0.5
            elif volatility_factor > 1.5:
                adaptive_cross_diff *= 1.3
                adaptive_ema_slope *= 1.4
                adaptive_volume_ratio *= 1.2
        else:
            adaptive_cross_diff = self.base_min_cross
            adaptive_ema_slope = self.base_min_slope
            adaptive_volume_ratio = 0.3

        qty_precision = self.bybit.get_qty_precision(self.symbol)
        coin = self.symbol.replace("USDT", "")
        balance_usdt = self.bybit.get_balance("USDT")
        quantity_usdt = round(balance_usdt, qty_precision) if balance_usdt else 0
        time_since_last_trade = (
            time.time() - self.last_trade_time if self.last_trade_time else 0
        )
        hours, remainder = divmod(time_since_last_trade, 3600)
        minutes, seconds = divmod(remainder, 60)
        time_display = f"{int(hours):02d}:{int(minutes):02d}:{int(seconds):02d}"

        unrealized_pnl = 0.0
        unrealized_pnl_pct = 0.0
        position_status = "‚ö†Ô∏è –ù–µ—Ç –æ—Ç–∫—Ä—ã—Ç–æ–π –ø–æ–∑–∏—Ü–∏–∏"
        if self.position_qty > 0:
            if self.avg_buy_price > 0:
                api_price = self.bybit.get_reliable_price(self.symbol)
                unrealized_pnl = (api_price - self.avg_buy_price) * self.position_qty
                net_profit = unrealized_pnl - api_price * self.position_qty * taker_fee
                unrealized_pnl_pct = (
                    net_profit / (self.avg_buy_price * self.position_qty)
                ) * 100

                if net_profit >= 0:
                    position_status = (
                        f"üí∞ –ü—Ä–∏–±—ã–ª—å: +{net_profit:.6f} USDT (+{unrealized_pnl_pct:.4f}%)"
                    )
                else:
                    position_status = (
                        f"üìâ –£–±—ã—Ç–æ–∫: {net_profit:.6f} USDT ({unrealized_pnl_pct:.4f}%)"
                    )
            else:
                position_status = "‚ö†Ô∏è –ü–æ–∑–∏—Ü–∏—è –µ—Å—Ç—å, –Ω–æ —Ü–µ–Ω–∞ –ø–æ–∫—É–ø–∫–∏ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞"

        vol_tag, vol_desc = grade_volatility(volatility_percent)
        atr_tag, atr_desc = grade_atr(atr, current_price)
        
        # –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π —Å—Ç–æ–ø-–ª–æ—Å—Å –Ω–∞ –æ—Å–Ω–æ–≤–µ ATR
        dynamic_stop_loss = self.max_loss
        if self.position_qty > 0 and self.avg_buy_price > 0:
            atr_contribution = atr * 2.5 / (self.avg_buy_price * self.position_qty)
            dynamic_stop_loss = max(self.max_loss, atr_contribution)

        # –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω—ã–π –≤—ã—Ö–æ–¥ –ø–æ –≤—Ä–µ–º–µ–Ω–∏
        if self.last_action == "BUY" and self.position_qty > 0:
            # –£—Å–ª–æ–≤–∏–µ 1: –µ—Å–ª–∏ —É–¥–µ—Ä–∂–∏–≤–∞–µ–º –±–æ–ª—å—à–µ 1 —á–∞—Å–∞ –∏ –≤ —É–±—ã—Ç–∫–µ
            if time_since_last_trade > 3600 and unrealized_pnl_pct < 0:
                log_maker(f"‚è±Ô∏è [TIME EXIT] –ü–æ–∑–∏—Ü–∏—è —É–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è >1 —á–∞—Å–∞ —Å —É–±—ã—Ç–∫–æ–º {unrealized_pnl_pct:.2f}%")
                return "SELL"

            # –£—Å–ª–æ–≤–∏–µ 2: –µ—Å–ª–∏ —É–¥–µ—Ä–∂–∏–≤–∞–µ–º –±–æ–ª—å—à–µ 30 –º–∏–Ω—É—Ç –∏ —É–±—ã—Ç–æ–∫ –±–æ–ª—å—à–µ 0.5%
            if time_since_last_trade > 1800 and unrealized_pnl_pct < -0.5:
                log_maker(f"üÜò [EMERGENCY EXIT] –ü–æ–∑–∏—Ü–∏—è —É–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è >30 –º–∏–Ω —Å —É–±—ã—Ç–∫–æ–º {unrealized_pnl_pct:.2f}%")
                return "SELL"

            # –≠–∫—Å—Ç—Ä–µ–Ω–Ω—ã–π –≤—ã—Ö–æ–¥ –ø—Ä–∏ –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ–º —É–±—ã—Ç–∫–µ
            if unrealized_pnl_pct < self.emergency_stop * 100:
                log_maker(f"üö® [EMERGENCY STOP] –£–±—ã—Ç–æ–∫ –ø—Ä–µ–≤—ã—Å–∏–ª {self.emergency_stop*100:.2f}%")
                return "SELL"

        stats_message = (
            f"üìä short EMA: {short_ema:.6f}\nüìä medium EMA:{medium_ema:.6f}\nüìä long EMA:{long_ema:.6f}\n"
            f"üí∞ –¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞: {current_price:.6f}\n"
            f"üì¶ –ë–∞–ª–∞–Ω—Å {coin}: {self.position_qty:.6f}\n"
            f"üíµ –ë–∞–ª–∞–Ω—Å USDT: {quantity_usdt:.6f}\n"
            f"{position_status}\n"
            f"üå™Ô∏è –í–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å: {volatility_percent:.4f}% ‚Üí {vol_tag} ({vol_desc})\n"
            f"üìè ATR: {atr:.6f} ‚Üí {atr_tag} ({atr_desc})\n"
            f"üü¢ Min profit: {min_profit_dynamic*100:.4f}% (base: {self.base_min_profit*100:.2f}%) | \n"
            f"üî¥ Max loss: {dynamic_stop_loss*100:.4f}%\n"
            f"üß≠ –ü–æ—Å–ª–µ–¥–Ω—è—è –æ–ø–µ—Ä–∞—Ü–∏—è: {self.last_action} –ø–æ —Ü–µ–Ω–µ {self.last_trade_price:.6f} USDT\n"
            f"‚è≥ –í—Ä–µ–º—è —É–¥–µ—Ä–∂–∞–Ω–∏—è: {time_display}\n"
        )

        failed_conditions = []

        # –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π —Ü–µ–Ω—ã
        if self.last_action == "BUY" and self.position_qty > 0:
            if self.max_price_since_buy is None:
                self.max_price_since_buy = current_price
            else:
                self.max_price_since_buy = max(self.max_price_since_buy, current_price)
                
            if current_price > self.max_price_since_buy:
                self.max_price_since_buy = current_price
                self.flat_counter = 0
            else:
                self.flat_counter += 1

            # –£–≤–µ–ª–∏—á–µ–Ω–æ –≤—Ä–µ–º—è –¥–ª—è —Ñ–ª—ç—Ç-–≤—ã—Ö–æ–¥–∞
            if (
                self.flat_counter >= self.flat_max_no_growth
                and unrealized_pnl_pct > self.flat_exit_profit
                and time_since_last_trade > self.min_hold_time_for_flat
            ):
                log_maker(
                    f"‚èπÔ∏è [FLAT EXIT] –¶–µ–Ω–∞ –Ω–µ —Ä–∞—Å—Ç—ë—Ç {self.flat_counter} —Å–≤–µ—á–µ–π, –≤—ã—Ö–æ–¥–∏–º –ø–æ –Ω–µ—É–±—ã—Ç–∫—É ({unrealized_pnl_pct:.2f}%)"
                )
                self.flat_counter = 0
                self.max_price_since_buy = None
                return "SELL"

        # –í—ã—Ö–æ–¥ –ø—Ä–∏ —Ñ–ª—ç—Ç–µ —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º —É–±—ã—Ç–∫–æ–º (—Å –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ–º –≤—Ä–µ–º–µ–Ω–∏ —É–¥–µ—Ä–∂–∞–Ω–∏—è)
        flat_condition = (
            self.last_action == "BUY"
            and volatility < self.flat_volatility_threshold
            and unrealized_pnl_pct >= -0.1
            and time_since_last_trade > self.min_hold_time_for_flat
        )
        if flat_condition:
            log_maker(f"üìà –ó–∞–∫—Ä—ã–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é —Å –ø—Ä–∏–±—ã–ª—å—é {unrealized_pnl_pct:.4f}%")
            return "SELL"
        elif self.last_action == "BUY":
            if not (volatility < self.flat_volatility_threshold):
                failed_conditions.append("–í–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å –≤—ã—à–µ –ø–æ—Ä–æ–≥–∞ —Ñ–ª—ç—Ç–∞")
            if not (unrealized_pnl_pct < 0):
                failed_conditions.append(
                    f"–ü–æ–∑–∏—Ü–∏—è –≤ –ø—Ä–∏–±—ã–ª–∏ ({unrealized_pnl_pct:.4f}%)"
                )

        if self.last_action == "BUY" and self.position_qty > 0:
            if self.max_price_since_buy is None:
                self.max_price_since_buy = current_price
            elif current_price > self.max_price_since_buy:
                self.max_price_since_buy = current_price

            if current_price >= self.avg_buy_price * (1 + min_profit_dynamic):
                trailing_stop_price = self.max_price_since_buy * (
                    1 - self.trailing_stop_distance
                )
                if current_price <= trailing_stop_price:
                    log_maker(
                        f"üîê [TRAILING STOP] –ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω: –ø–∏–∫ {self.max_price_since_buy:.6f}, —Ç–µ–∫—É—â–∞—è {current_price:.6f}"
                    )
                    return "SELL"
                else:
                    failed_conditions.append(
                        f"–¢—Ä–µ–π–ª–∏–Ω–≥-—Å—Ç–æ–ø: —Ü–µ–Ω–∞ ({current_price:.6f}) > —Å—Ç–æ–ø–∞ ({trailing_stop_price:.6f})"
                    )
            else:
                failed_conditions.append(
                    f"–¢—Ä–µ–π–ª–∏–Ω–≥-—Å—Ç–æ–ø: –Ω–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω (–ø—Ä–∏–±—ã–ª—å < {min_profit_dynamic*100:.4f}%)"
                )

        stop_loss_condition = (
            self.last_action == "BUY"
            and self.position_qty > 0
            and unrealized_pnl_pct <= -dynamic_stop_loss * 100
            and time_since_last_trade > 10 * 60
        )
        if stop_loss_condition:
            log_maker(
                f"üõë [STOP LOSS] –£–±—ã—Ç–æ–∫ {unrealized_pnl_pct:.4f}% –¥–æ—Å—Ç–∏–≥ –º–∞–∫—Å–∏–º—É–º–∞ {-dynamic_stop_loss*100:.4f}%"
            )
            return "SELL"
        elif self.last_action == "BUY" and self.position_qty > 0:
            failed_conditions.append(
                f"–°—Ç–æ–ø-–ª–æ—Å—Å: —É–±—ã—Ç–æ–∫ {unrealized_pnl_pct:.4f}% > –ø–æ—Ä–æ–≥–∞ {-dynamic_stop_loss*100:.4f}%"
            )

        # –ß–∞—Å—Ç–∏—á–Ω—ã–π –≤—ã—Ö–æ–¥ –ø—Ä–∏ —É–±—ã—Ç–∫–∞—Ö
        partial_exit_condition = (
            self.last_action == "BUY"
            and self.position_qty > 0
            and unrealized_pnl_pct < self.partial_exit_level * 100
            and not self.partial_exit_taken
        )

        if partial_exit_condition:
            log_maker(f"üü° [PARTIAL EXIT] –£–±—ã—Ç–æ–∫ –¥–æ—Å—Ç–∏–≥ {self.partial_exit_level*100:.2f}%, –ø—Ä–æ–¥–∞–µ–º {self.partial_exit_pct*100:.0f}% –ø–æ–∑–∏—Ü–∏–∏")
            self.partial_exit_taken = True
            return "SELL_PARTIAL"

        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —Å–∏–≥–Ω–∞–ª–∞
        if self.pending_signal and self.require_confirmation:
            self.signal_confirmation_count += 1
            
            # –ï—Å–ª–∏ —Å–∏–≥–Ω–∞–ª –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω –¥–æ—Å—Ç–∞—Ç–æ—á–Ω—ã–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º —Å–≤–µ—á–µ–π
            if self.signal_confirmation_count >= self.confirmation_period:
                confirmed_signal = self.pending_signal
                self.pending_signal = None
                self.signal_confirmation_count = 0
                return confirmed_signal
            else:
                log_maker(f"‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è —Å–∏–≥–Ω–∞–ª–∞ ({self.signal_confirmation_count}/{self.confirmation_period})")
                return None

        if self.prev_short_ema is not None and self.prev_medium_ema is not None:
            short_medium_diff = (
                ((short_ema - medium_ema) / medium_ema) * 100 if medium_ema > 0 else 0
            )

            avg_volume = (
                np.mean(volumes[-self.volume_lookback :])
                if len(volumes) >= self.volume_lookback
                else 0
            )
            current_volume = volumes[-1] if volumes else 0
            volume_ratio = current_volume / avg_volume if avg_volume > 0 else 1

            slope_desc = grade_slope(short_ema_slope)
            ema_diff_desc = grade_ema_diff(short_medium_diff)

            log_maker(
                f"üìâ EMA Diff: S/M: {short_medium_diff:.4f}% (min: {adaptive_cross_diff:.4f}%) ‚Üí {ema_diff_desc}\n"
                f"üìê –ù–∞–∫–ª–æ–Ω short: {short_ema_slope:.4f}% (min: {adaptive_ema_slope:.4f}%) ‚Üí {slope_desc}\n"
                f"üìä –û–±—ä–µ–º: {volume_ratio:.2f}x (min: {adaptive_volume_ratio:.2f}x)\n"
            )

            trend_strength = 0
            if len(self.ema_history) >= 5:
                for i in range(1, min(6, len(self.ema_history))):
                    if (
                        i < len(self.ema_history)
                        and self.ema_history[-i] > self.prev_medium_ema
                    ):
                        trend_strength += 1

            entry_condition = False
            entry_type = ""
            if not entry_condition:
                if short_ema <= medium_ema:
                    failed_conditions.append("Short EMA ‚â§ Medium EMA")
                elif short_ema_slope <= 0:
                    failed_conditions.append("–ù–∞–∫–ª–æ–Ω short EMA ‚â§ 0")
                elif current_price <= max(c["close"] for c in candles[-6:-1]):
                    failed_conditions.append("–¶–µ–Ω–∞ –Ω–µ –æ–±–Ω–æ–≤–∏–ª–∞ –ª–æ–∫–∞–ª—å–Ω—ã–π –º–∞–∫—Å–∏–º—É–º")
            if self.prev_short_ema <= self.prev_medium_ema and short_ema > medium_ema:
                entry_condition = True
                entry_type = "üÜï –ù–æ–≤—ã–π –≤–æ—Å—Ö–æ–¥—è—â–∏–π –∫—Ä–æ—Å—Å"
            elif (
                trend_strength >= self.required_trend_strength
                and short_ema > medium_ema
                and short_ema_slope > 0
                and current_price > max(c["close"] for c in candles[-6:-1])
            ):
                entry_condition = True
                entry_type = "üìà –ü—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ —Å–∏–ª—å–Ω–æ–≥–æ —Ç—Ä–µ–Ω–¥–∞"

            if entry_condition:
                # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã –≤—Ö–æ–¥–∞
                if short_ema_slope < 0.00015:  # –ë–æ–ª–µ–µ —Å—Ç—Ä–æ–≥–∏–π —Ñ–∏–ª—å—Ç—Ä –Ω–∞–∫–ª–æ–Ω–∞
                    log_maker("‚è© –ü—Ä–æ–ø—É—Å–∫ BUY: —Å–ª–∞–±—ã–π —Ç—Ä–µ–Ω–¥ (–Ω–∞–∫–ª–æ–Ω EMA < 0.00015)")
                    return None

                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–±—ä–µ–º–∞ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ ATR
                volume_threshold = atr * 1500  # –£–≤–µ–ª–∏—á–µ–Ω –ø–æ—Ä–æ–≥
                if current_volume < volume_threshold:
                    log_maker(f"‚è© –ü—Ä–æ–ø—É—Å–∫ BUY: –æ–±—ä–µ–º {current_volume} < ATR-–ø–æ—Ä–æ–≥–∞ {volume_threshold:.2f}")
                    return None

                # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–∏–ª—ã —Ç—Ä–µ–Ω–¥–∞
                if trend_strength < self.required_trend_strength:
                    log_maker(f"‚è© –ü—Ä–æ–ø—É—Å–∫ BUY: —Å–∏–ª–∞ —Ç—Ä–µ–Ω–¥–∞ {trend_strength} < —Ç—Ä–µ–±—É–µ–º–æ–π {self.required_trend_strength}")
                    return None

                if self.last_action == "BUY":
                    volatility_adjustment = max(0.5, min(2.0, volatility_factor))
                    min_time_since_last_buy = int(self.min_hold_time / volatility_adjustment)
                    if time_since_last_trade < min_time_since_last_buy:
                        log_maker(
                            f"‚è±Ô∏è –ó–∞—â–∏—Ç–∞: –ø–æ—Å–ª–µ–¥–Ω—è—è –ø–æ–∫—É–ø–∫–∞ –±—ã–ª–∞ {time_display} –Ω–∞–∑–∞–¥, –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª: {min_time_since_last_buy//60} –º–∏–Ω"
                        )
                        failed_conditions.append("–ó–∞—â–∏—Ç–∞ –æ—Ç —á–∞—Å—Ç—ã—Ö –≤—Ö–æ–¥–æ–≤")
                        entry_condition = False

                condition_cross = short_medium_diff >= adaptive_cross_diff
                condition_slope = short_ema_slope >= adaptive_ema_slope
                condition_volume = volume_ratio >= adaptive_volume_ratio
                conditions_met = sum([condition_cross, condition_slope, condition_volume])

                strong_slope_condition = (
                    short_ema_slope >= 0.018
                    and (condition_cross or condition_volume) and
                    volume_ratio >= 0.08
                )

                buy_condition = (
                    balance_usdt >= 5 and
                    (conditions_met >= 2 or strong_slope_condition)
                )

                strong_trend = short_ema_slope > 0.015 or volume_ratio > 1.5
                if buy_condition and current_price > upper_level - level_delta and not strong_trend:
                    log_maker(
                        f"‚õî [LEVEL FILTER] –¶–µ–Ω–∞ {current_price:.2f} –±–ª–∏–∑–∫–æ –∫ –≤–µ—Ä—Ö–Ω–µ–π –≥—Ä–∞–Ω–∏—Ü–µ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ ({upper_level:.2f})"
                    )
                    failed_conditions.append("–¶–µ–Ω–∞ –±–ª–∏–∑–∫–æ –∫ –≤–µ—Ä—Ö–Ω–µ–π –≥—Ä–∞–Ω–∏—Ü–µ –¥–∏–∞–ø–∞–∑–æ–Ω–∞")
                    buy_condition = False

                if buy_condition:
                    risk = atr * 2
                    reward = atr * 4
                    risk_reward_ratio = reward / risk if risk > 0 else 0
                    
                    if risk_reward_ratio < self.min_risk_reward_ratio:
                        log_maker(f"‚è© –ü—Ä–æ–ø—É—Å–∫ BUY: —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ —Ä–∏—Å–∫/–ø—Ä–∏–±—ã–ª—å {risk_reward_ratio:.1f} < {self.min_risk_reward_ratio:.1f}")
                        buy_condition = False
                        failed_conditions.append(f"–°–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ R/R {risk_reward_ratio:.1f} < {self.min_risk_reward_ratio:.1f}")

                if buy_condition:
                    hourly_trend = self._check_hourly_trend()
                    if hourly_trend == -1:
                        log_maker("‚è© –ü—Ä–æ–ø—É—Å–∫ BUY: –Ω–∏—Å—Ö–æ–¥—è—â–∏–π —Ç—Ä–µ–Ω–¥ –Ω–∞ —á–∞—Å–æ–≤–æ–º –≥—Ä–∞—Ñ–∏–∫–µ")
                        buy_condition = False
                        failed_conditions.append("–ù–∏—Å—Ö–æ–¥—è—â–∏–π —Ç—Ä–µ–Ω–¥ –Ω–∞ 1H")

                if buy_condition:
                    reason = ""
                    if strong_slope_condition:
                        reason = "üìà –°–ò–õ–¨–ù–´–ô –ù–ê–ö–õ–û–ù + –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ —É—Å–ª–æ–≤–∏–µ"
                    elif conditions_met >= 2:
                        reason = f"‚úÖ {conditions_met} –∏–∑ 3 —É—Å–ª–æ–≤–∏–π –≤—ã–ø–æ–ª–Ω–µ–Ω–æ"
                    log_maker(f"üì• [BUY SIGNAL] {entry_type} | –ü—Ä–∏—á–∏–Ω–∞: {reason}\n"
                            f"  ‚Ä¢ –†–∞–∑–Ω–∏—Ü–∞ EMA: {short_medium_diff:.4f}% {'‚úÖ' if condition_cross else '‚ùå'} (–ø–æ—Ä–æ–≥: {adaptive_cross_diff:.4f}%)\n"
                            f"  ‚Ä¢ –ù–∞–∫–ª–æ–Ω EMA: {short_ema_slope:.4f}% {'‚úÖ' if condition_slope else '‚ùå'} (–ø–æ—Ä–æ–≥: {adaptive_ema_slope:.4f}%)\n"
                            f"  ‚Ä¢ –û–±—ä–µ–º: {volume_ratio:.2f}x {'‚úÖ' if condition_volume else '‚ùå'} (–ø–æ—Ä–æ–≥: {adaptive_volume_ratio:.2f}x)")
                    
                    # –í–º–µ—Å—Ç–æ –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ–≥–æ –≤—Ö–æ–¥–∞, —Å—Ç–∞–≤–∏–º —Å–∏–≥–Ω–∞–ª –Ω–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ
                    if self.require_confirmation:
                        self.pending_signal = "BUY"
                        self.signal_confirmation_count = 1
                        log_maker(f"üü° –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω—ã–π —Å–∏–≥–Ω–∞–ª BUY. –û–∂–∏–¥–∞—é –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.")
                        return None
                    else:
                        self.max_price_since_buy = current_price
                        self.ma_crossed_down = False
                        return "BUY"
                else:
                    buy_failed = []
                    if not (short_medium_diff >= adaptive_cross_diff):
                        buy_failed.append(
                            f"–†–∞–∑–Ω–∏—Ü–∞ EMA S/M ({short_medium_diff:.4f}% < {adaptive_cross_diff:.4f}%)"
                        )
                    if not (short_ema_slope >= adaptive_ema_slope):
                        buy_failed.append(
                            f"–ù–∞–∫–ª–æ–Ω short EMA ({short_ema_slope:.4f}% < {adaptive_ema_slope:.4f}%)"
                        )
                    if not (volume_ratio >= adaptive_volume_ratio):
                        buy_failed.append(
                            f"–û–±—ä–µ–º ({volume_ratio:.2f}x < {adaptive_volume_ratio:.2f}x)"
                        )
                    if buy_failed:
                        failed_conditions.append(
                            f"–£—Å–ª–æ–≤–∏—è –ø–æ–∫—É–ø–∫–∏: " + ", ".join(buy_failed)
                        )

            if self.prev_short_ema <= self.prev_medium_ema and short_ema > medium_ema:
                if self.ma_crossed_down:
                    log_maker("üü¢ –°–±—Ä–æ—Å —Ñ–ª–∞–≥–∞ –≤—ã—Ö–æ–¥–∞ (MA –∫—Ä–æ—Å—Å –≤–≤–µ—Ä—Ö)")
                    self.ma_crossed_down = False

            if (
                self.ma_crossed_down
                and self.last_action == "BUY"
                and self.position_qty > 0
            ):
                time_in_trade = time.time() - self.last_trade_time
                if time_in_trade < self.min_hold_time:
                    log_maker(
                        f"‚è±Ô∏è –£–¥–µ—Ä–∂–∏–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é ({time_in_trade/60:.1f} –º–∏–Ω < {self.min_hold_time/60} –º–∏–Ω)"
                    )
                    failed_conditions.append(
                        f"–ó–∞—â–∏—Ç–∞: –ø–æ–∑–∏—Ü–∏—è —É–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è –º–µ–Ω–µ–µ {self.min_hold_time/60} –º–∏–Ω"
                    )
                elif current_price and self.avg_buy_price:
                    min_net_profit = min_profit_dynamic * 100 + 0.1
                    if unrealized_pnl_pct >= min_net_profit:
                        log_maker(
                            f"üí∞ [SELL SIGNAL] Net Profit: {unrealized_pnl_pct:.4f}% ‚â• {min_net_profit:.4f}%"
                        )
                        return "SELL"
                    elif short_ema > medium_ema:
                        log_maker("‚ö†Ô∏è –û—Ç–º–µ–Ω—è–µ–º –≤—ã—Ö–æ–¥ - MA –∫—Ä–æ—Å—Å –≤–Ω–∏–∑ –±—ã–ª –ª–æ–∂–Ω—ã–º")
                        self.ma_crossed_down = False
                    else:
                        failed_conditions.append(
                            f"–í—ã—Ö–æ–¥ –ø–æ —Ñ–ª–∞–≥—É: –ø—Ä–∏–±—ã–ª—å {unrealized_pnl_pct:.4f}% < –º–∏–Ω. {min_net_profit:.4f}%"
                        )
                else:
                    failed_conditions.append("–í—ã—Ö–æ–¥ –ø–æ —Ñ–ª–∞–≥—É: –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ —Ü–µ–Ω–µ")

            if self.prev_short_ema >= self.prev_medium_ema and short_ema < medium_ema:
                if self.last_action == "BUY" and self.position_qty > 0:
                    self.ma_crossed_down = True
                    log_maker("‚ö†Ô∏è MA cross down - exit flag set")
                else:
                    log_maker("‚ö†Ô∏è MA cross down (no position)")

        if (
            self.position_qty == 0
            and len(closes) > 8
            and all(closes[-i] < closes[-i-1] for i in range(7,2,-1))
            and closes[-2] < closes[-1]
            and current_price < short_ema * 1.01
            and current_price < upper_level - level_delta
            and balance_usdt >= 5
        ):
            risk = atr * 2
            reward = atr * 4
            risk_reward_ratio = reward / risk if risk > 0 else 0
            
            if risk_reward_ratio >= self.min_risk_reward_ratio:
                # –í—Ö–æ–¥ –ø–æ –æ—Ç—Å–∫–æ–∫—É —Ç–∞–∫–∂–µ —Ç—Ä–µ–±—É–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
                if self.require_confirmation:
                    self.pending_signal = "BUY"
                    self.signal_confirmation_count = 1
                    log_maker(f"üü° –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω—ã–π —Å–∏–≥–Ω–∞–ª BOUNCE BUY. –û–∂–∏–¥–∞—é –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.")
                    return None
                else:
                    log_maker("üìà [BOUNCE ENTRY] –í—Ö–æ–¥ –ø–æ –æ—Ç—Å–∫–æ–∫—É –ø–æ—Å–ª–µ –ø–∞–¥–µ–Ω–∏—è")
                    self.max_price_since_buy = current_price
                    self.ma_crossed_down = False
                    return "BUY"
            else:
                log_maker(f"‚è© –ü—Ä–æ–ø—É—Å–∫ BOUNCE: —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ —Ä–∏—Å–∫/–ø—Ä–∏–±—ã–ª—å {risk_reward_ratio:.1f} < {self.min_risk_reward_ratio:.1f}")

        self.prev_short_ema = short_ema
        self.prev_medium_ema = medium_ema
        self.prev_long_ema = long_ema

        log_maker(stats_message)

        if self.trade_opportunities % 50 == 0 and self.trade_opportunities > 0:
            ratio = self.executed_trades / self.trade_opportunities
            log_maker(f"üìä –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å: {self.executed_trades}/{self.trade_opportunities} ({ratio:.1%}) —Å–∏–≥–Ω–∞–ª–æ–≤ –∏—Å–ø–æ–ª–Ω–µ–Ω–æ")
            
            if ratio < 0.1:
                self.base_min_cross *= 0.9
                self.base_min_slope *= 0.85
                log_maker(f"üîß –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤: min_cross={self.base_min_cross:.6f}, min_slope={self.base_min_slope:.6f}")
            
            elif ratio > 0.3:
                self.base_min_cross *= 1.1
                self.base_min_slope *= 1.15
                log_maker(f"üîß –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤: min_cross={self.base_min_cross:.6f}, min_slope={self.base_min_slope:.6f}")

        if failed_conditions:
            log_maker("üîç –ù–µ –≤—ã–ø–æ–ª–Ω–µ–Ω—ã —É—Å–ª–æ–≤–∏—è:")
            for condition in failed_conditions:
                log_maker(f"   - {condition}")
        else:
            log_maker("‚è∏Ô∏è –ù–∏ –æ–¥–Ω–æ —Ç–æ—Ä–≥–æ–≤–æ–µ —É—Å–ª–æ–≤–∏–µ –Ω–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ")

        return None

    def execute_trade(self, action: str, executor):
        """–ò—Å–ø–æ–ª–Ω–µ–Ω–∏–µ —Ç–æ—Ä–≥–æ–≤–æ–≥–æ —Å–∏–≥–Ω–∞–ª–∞ —Å –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏—è"""
        if action == "BUY":
            # –ü–µ—Ä–µ–¥–∞–µ–º trading_system –≤ execute_buy
            if executor.execute_buy(trading_system=self.trading_system):
                self._init_state_from_api()
        elif action == "SELL":
            if executor.execute_sell(strategy=self):
                self._init_state_from_api()

    

===== ./trader.py =====
from decimal import ROUND_DOWN, Decimal
from app.notifier import send_telegram_message
from app.utils.log_helper import log_maker
from pybit.unified_trading import HTTP
from app.services.bybit_service import BybitService
from app.config import BYBIT_API_KEY, BYBIT_API_SECRET, IS_TESTNET

client = HTTP(
    testnet=IS_TESTNET,
    api_key=BYBIT_API_KEY,
    api_secret=BYBIT_API_SECRET,
    recv_window=15000,
)
bybit = BybitService()



def validate_qty_precision(symbol: str, qty: float):
    precision = bybit.get_qty_precision(symbol)
    parts = str(qty).split(".")
    decimal_digits = len(parts[1]) if len(parts) == 2 else 0

    if decimal_digits > precision:
        send_telegram_message(
            f"üö® [CRITICAL] qty = {qty} —Å–æ–¥–µ—Ä–∂–∏—Ç {decimal_digits} –∑–Ω–∞–∫–æ–≤ –ø–æ—Å–ª–µ –∑–∞–ø—è—Ç–æ–π, "
            f"—á—Ç–æ –ø—Ä–µ–≤—ã—à–∞–µ—Ç –¥–æ–ø—É—Å—Ç–∏–º—É—é —Ç–æ—á–Ω–æ—Å—Ç—å ({precision}) –¥–ª—è {symbol}. "
            f"–£–±–µ–¥–∏—Å—å, —á—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è `round_qty(...)`!"
        )
        raise ValueError(
            f"[CRITICAL] qty={qty} —Å–æ–¥–µ—Ä–∂–∏—Ç {decimal_digits} –∑–Ω–∞–∫–æ–≤ –ø–æ—Å–ª–µ –∑–∞–ø—è—Ç–æ–π, "
            f"—á—Ç–æ –ø—Ä–µ–≤—ã—à–∞–µ—Ç –¥–æ–ø—É—Å—Ç–∏–º—É—é —Ç–æ—á–Ω–æ—Å—Ç—å ({precision}) –¥–ª—è {symbol}. "
            f"–ü—Ä–æ–≤–µ—Ä—å, —á—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è round_qty(...)!"
        )



def translate_status(status):
    return {
        "Filled": "–∏—Å–ø–æ–ª–Ω–µ–Ω–æ",
        "Cancelled": "–æ—Ç–º–µ–Ω–µ–Ω–æ",
        "Rejected": "–æ—Ç–∫–ª–æ–Ω–µ–Ω–æ",
        "New": "–Ω–æ–≤—ã–π",
        "PartiallyFilled": "—á–∞—Å—Ç–∏—á–Ω–æ –∏—Å–ø–æ–ª–Ω–µ–Ω–æ",
    }.get(status, status)




def get_price_history(symbol: str, interval: str = "3", limit: int = 100):
    """–¢–û–õ–¨–ö–û API-–¥–∞–Ω–Ω—ã–µ"""
    try:
        return bybit.get_candles(
            symbol=symbol,
            interval=interval,  # –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä
            limit=limit
        )
    except Exception as e:
        log_maker(f"üìâ [ERROR] –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏—Å—Ç–æ—Ä–∏–∏ —Ü–µ–Ω: {e}")
        return []



===== ./config.py =====
import os
from dotenv import load_dotenv
load_dotenv()

TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
TELEGRAM_BOT_TOKEN_TRADES = os.getenv("TELEGRAM_BOT_TOKEN_TRADES")
TELEGRAM_USER_ID = os.getenv("TELEGRAM_USER_ID")

BYBIT_API_KEY = os.getenv("BYBIT_API_KEY", "your_api_key")
BYBIT_API_SECRET = os.getenv("BYBIT_API_SECRET", "your_api_secret")
IS_TESTNET = False

symbol = "SOLUSDT"

===== ./trading/order_executor.py =====
from decimal import ROUND_DOWN, Decimal
import time
from app.notifier import send_telegram_message
from app.utils.log_helper import log_maker
from pybit.unified_trading import HTTP
from app.services.bybit_service import BybitService
from app.config import BYBIT_API_KEY, BYBIT_API_SECRET, IS_TESTNET

client = HTTP(
    testnet=IS_TESTNET,
    api_key=BYBIT_API_KEY,
    api_secret=BYBIT_API_SECRET,
    recv_window=15000,
)
bybit = BybitService()

class OrderExecutor:
    def __init__(self, symbol: str):
        self.symbol = symbol
        self.bybit = BybitService()
        self.last_buy_price = 0.0
        self.last_buy_quantity = 0.0
        
    def execute_force_close(self) -> bool:
        coin = self.symbol.replace("USDT", "")
        balance = self.bybit.get_balance(coin)
        if not balance or balance <= 0:
            log_maker(f"‚è© –ù–µ—Ç –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–≥–æ –∑–∞–∫—Ä—ã—Ç–∏—è {self.symbol}")
            return False
            
        log_maker(f"üÜò [FORCE CLOSE] –ü—Ä–æ–¥–∞–µ–º {balance} {coin}", buy_sell=True)
        return self.execute_sell(None)
        
    def execute_buy(self, trading_system=None):
        usdt_balance = self.bybit.get_balance("USDT")
        if not usdt_balance:
            log_maker("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –±–∞–ª–∞–Ω—Å USDT")
            return False
            
        usdt_balance = max(0, usdt_balance - 0.1)
        usdt_balance = round(usdt_balance, 2)

        if usdt_balance < 5:
            log_maker("‚è© –ü—Ä–æ–ø—É—Å–∫ BUY: –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤")
            return False

        price = self.bybit.get_reliable_price(self.symbol)
        if not price:
            log_maker("‚è© –ü—Ä–æ–ø—É—Å–∫ BUY: –Ω–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ü–µ–Ω—É")
            return False

        log_maker(f"üü¢ [BOT] –ü–æ–∫—É–ø–∞–µ–º {self.symbol} –Ω–∞ {usdt_balance:.2f} USDT", buy_sell=True)
        order_response = self.bybit.market_order(
            self.symbol, "Buy", usdt_balance, is_quote=True
        )

        if order_response and order_response.get("retCode") == 0:
            log_maker("‚úÖ –û—Ä–¥–µ—Ä –Ω–∞ –ø–æ–∫—É–ø–∫—É —É—Å–ø–µ—à–Ω–æ —Ä–∞–∑–º–µ—â–µ–Ω")
            if trading_system:
                trading_system.position_open_time = time.time()
                trading_system.position_coin = self.symbol.replace('USDT', '')
            
            filled_order = self.bybit.get_last_filled_order(self.symbol)
            if filled_order:
                qty_coin = float(filled_order.get("cumExecQty", 0))
                avg_price = float(filled_order.get("avg_price", 0))
                self.last_buy_price = avg_price
                self.last_buy_quantity = qty_coin
                
                if trading_system:
                    trading_system.position_open_time = time.time()
                
                log_maker(
                    f"‚úÖ –ö—É–ø–ª–µ–Ω–æ: {qty_coin} {self.symbol.replace('USDT', '')} –ø–æ {avg_price:.5f} USDT",
                    buy_sell=True,
                )
                return True
        return False

    def execute_sell(self, strategy=None):
        coin = self.symbol.replace("USDT", "")
        balance = self.bybit.get_balance(coin)
        if not balance:
            log_maker(f"ü§∑ –ù–µ—Ç –ø–æ–∑–∏—Ü–∏–∏ –ø–æ {coin}")
            return False

        min_qty = self.bybit.get_min_order_qty(self.symbol)
        if balance < min_qty:
            log_maker(f"‚è© –ü—Ä–æ–ø—É—Å–∫ SELL: –±–∞–ª–∞–Ω—Å {balance} < –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ {min_qty}")
            return False

        log_maker(f"üîª [BOT] –ü—Ä–æ–¥–∞—ë–º {balance} {coin}", buy_sell=True)
        order_response = self.bybit.market_order(
            self.symbol, "Sell", balance, is_quote=False
        )

        if order_response and order_response.get("retCode") == 0:
            log_maker("‚úÖ –û—Ä–¥–µ—Ä –Ω–∞ –ø—Ä–æ–¥–∞–∂—É —É—Å–ø–µ—à–Ω–æ —Ä–∞–∑–º–µ—â–µ–Ω", buy_sell=True)
            filled_order = self.bybit.get_last_filled_order(self.symbol)
            if filled_order:
                qty_coin = float(filled_order.get("cumExecQty", 0))
                avg_price = float(filled_order.get("avg_price", 0))
                exec_fee = float(filled_order.get("cumExecFee", 0))
                
                profit = 0.0
                if self.last_buy_price > 0:
                    buy_value = self.last_buy_price * qty_coin
                    sell_value = avg_price * qty_coin
                    profit = sell_value - buy_value - exec_fee
                    
                    if hasattr(strategy, "rotator") and strategy.rotator:
                        strategy.rotator.record_trade_result(profit)
                    
                    profit_pct = (profit / buy_value) * 100
                    profit_msg = (f"üü¢ –ß–∏—Å—Ç–∞—è –ø—Ä–∏–±—ã–ª—å: +{profit:.4f} USDT (+{profit_pct:.2f}%)" 
                                if profit >= 0 else 
                                f"üî¥ –ß–∏—Å—Ç—ã–π —É–±—ã—Ç–æ–∫: {profit:.4f} USDT ({profit_pct:.2f}%)")
                    
                    log_maker(
                        f"üí∞ –ü—Ä–æ–¥–∞–Ω–æ: {qty_coin} {coin} –ø–æ {avg_price:.5f} USDT\n"
                        f"  ‚Ä¢ {profit_msg}\n"
                        f"  ‚Ä¢ –ö–æ–º–∏—Å—Å–∏–∏: {exec_fee:.4f} USDT",
                        buy_sell=True,
                    )
                return True
        return False
    
    def clean_residuals(self, threshold=0.0001):
        coin = self.symbol.replace('USDT', '')
        balance = self.bybit.get_balance(coin)
        if not balance:
            return
                
        min_qty = self.bybit.get_min_order_qty(self.symbol)
        
        # –ï—Å–ª–∏ –±–∞–ª–∞–Ω—Å –º–µ–Ω—å—à–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –ª–æ—Ç–∞ –ò–õ–ò –º–µ–Ω—å—à–µ –ø–æ—Ä–æ–≥–æ–≤–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è
        if balance < min_qty or balance < threshold:
            precision = self.bybit.get_qty_precision(self.symbol)
            # –û–∫—Ä—É–≥–ª—è–µ–º –¥–æ –¥–æ–ø—É—Å—Ç–∏–º–æ–π —Ç–æ—á–Ω–æ—Å—Ç–∏
            qty = round(balance, precision)
            
            if qty <= 0:
                log_maker(f"‚è© –û—Å—Ç–∞—Ç–æ–∫ {balance} {coin} —Å–ª–∏—à–∫–æ–º –º–∞–ª –¥–ª—è –ø—Ä–æ–¥–∞–∂–∏")
                return
                
            log_maker(f"üßπ –û—á–∏—Å—Ç–∫–∞ –æ—Å—Ç–∞—Ç–∫–∞ {qty} {coin}", buy_sell=True)
            order_response = self.bybit.market_order(
                self.symbol, "Sell", qty, is_quote=False
            )

            if order_response and order_response.get("retCode") == 0:
                log_maker(f"‚úÖ –û—Å—Ç–∞—Ç–æ–∫ {qty} {coin} —É—Å–ø–µ—à–Ω–æ –ø—Ä–æ–¥–∞–Ω", buy_sell=True)
            else:
                error = order_response.get("retMsg") if order_response else "Unknown error"
                log_maker(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–¥–∞—Ç—å –æ—Å—Ç–∞—Ç–æ–∫: {error}", buy_sell=True)

===== ./trading/__init__.py =====
from .data_provider import DataProvider
from .order_executor import OrderExecutor

__all__ = ['DataProvider', 'OrderExecutor']


===== ./trading/data_provider.py =====
# ===== ./app/trader/data_provider.py =====
from app.services.bybit_service import BybitService
from app.utils.log_helper import log_maker

class DataProvider:
    def __init__(self, symbol: str, interval: str):
        self.symbol = symbol
        self.interval = interval
        self.bybit = BybitService()
        self.controller = None
    
    def get_candles(self, limit: int = 200):
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω—ã
        if self.controller and hasattr(self.controller, 'preloaded_data'):
            coin = self.symbol.replace('USDT', '')
            if coin in self.controller.preloaded_data:
                preloaded = self.controller.preloaded_data[coin]
                if len(preloaded) >= limit:
                    return preloaded[-limit:]
        
        # –ï—Å–ª–∏ –Ω–µ—Ç –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∂–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö, –∑–∞–≥—Ä—É–∂–∞–µ–º –∏–∑ API
        try:
            candles = self.bybit.get_candles(
                self.symbol, 
                interval=self.interval, 
                limit=limit
            )
            
            if len(candles) < limit // 2:
                log_maker(f"‚ö†Ô∏è –ü–æ–ª—É—á–µ–Ω–æ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å–≤–µ—á–µ–π: {len(candles)} –∏–∑ {limit}")
                
            return candles
        except Exception as e:
            log_maker(f"üî• –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö: {e}")
            return []

===== ./api/routes/bot_control.py =====
from fastapi import APIRouter
from app.services.bot_controller import bot_controller

router = APIRouter()

@router.post("/start")
def start_bot():
    bot_controller.start()
    return {"status": "started"}

@router.post("/stop")
def stop_bot():
    bot_controller.stop()
    return {"status": "stopped"}

@router.get("/status")
def bot_status():
    return {"status": bot_controller.status()}


===== ./api/routes/trade_log.py =====
from app.notifier import send_telegram_message
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.database.engine import create_db
from app.database.models import TradeLog


router = APIRouter()

@router.get("/trade")
def get_trade_log(limit: int = 20, db: Session = Depends(create_db)):
    try:
        logs = db.query(TradeLog).order_by(TradeLog.timestamp.desc()).limit(limit).all()
        return [
            {
                "symbol": log.symbol,
                "side": log.side,
                "qty": log.qty,
                "price": log.avg_price,
                "status": log.status,
                "time": log.timestamp.isoformat()
            }
            for log in logs
        ]
    except Exception as e:
        import traceback
        traceback.print_exc()
        send_telegram_message("error in get_trade_log: " + str(e))
        return {"error": str(e)}


===== ./api/routes/__init__.py =====


===== ./__init__.py =====


===== ./indicators/market_grades.py =====
# app/indicators/market_grades.py

def grade_volatility(value: float) -> tuple[str, str]:
    if value < 0.15:
        return "üîµ –û—á–µ–Ω—å –Ω–∏–∑–∫–∞—è", "–§–ª—ç—Ç, –¥–≤–∏–∂–µ–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç"
    elif value < 0.3:
        return "üü¢ –£–º–µ—Ä–µ–Ω–Ω–∞—è", "–õ—ë–≥–∫–æ–µ –∫–æ–ª–µ–±–∞–Ω–∏–µ, —Å–ª–∞–±–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å"
    elif value < 0.6:
        return "üü° –°—Ä–µ–¥–Ω—è—è", "–£–º–µ—Ä–µ–Ω–Ω–∞—è –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å"
    else:
        return "üü† –í—ã—Å–æ–∫–∞—è", "–°–∏–ª—å–Ω—ã–µ –∫–æ–ª–µ–±–∞–Ω–∏—è, –≤–æ–∑–º–æ–∂–Ω—ã —Ä–µ–∑–∫–∏–µ –¥–≤–∏–∂–µ–Ω–∏—è —Ü–µ–Ω—ã"


def grade_atr(atr: float, current_price: float) -> tuple[str, str]:
    percent = (atr / current_price) * 100
    if percent < 0.3:
        return "üîµ –û—á–µ–Ω—å –Ω–∏–∑–∫–∏–π", "–§–ª—ç—Ç, –¥–≤–∏–∂–µ–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç"
    elif percent < 0.7:
        return "üü° –°—Ä–µ–¥–Ω–∏–π", "–ù–æ—Ä–º–∞–ª—å–Ω–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å"
    else:
        return "üü† –í—ã—Å–æ–∫–∏–π", "–†—ã–Ω–æ–∫ –¥—ã—à–∏—Ç —à–∏—Ä–æ–∫–æ, –≤—ã—Å–æ–∫–∞—è –∞–º–ø–ª–∏—Ç—É–¥–∞ –¥–≤–∏–∂–µ–Ω–∏—è"


def grade_slope(value: float) -> str:
    if value < 0.02:
        return '–§–ª—ç—Ç / —Å—Ç–∞–≥–Ω–∞—Ü–∏—è'
    elif value < 0.08:
        return '–°–ª–∞–±–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ'
    elif value < 0.2:
        return '–°—Ä–µ–¥–Ω—è—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å'
    else:
        return '–°–∏–ª—å–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ'


def grade_ema_diff(value: float) -> str:
    if value < 0.1:
        return '–û—á–µ–Ω—å —Å–ª–∞–±—ã–π —Ç—Ä–µ–Ω–¥'
    elif value < 0.3:
        return '–°–ª–∞–±—ã–π —Ç—Ä–µ–Ω–¥'
    elif value < 0.7:
        return '–£–º–µ—Ä–µ–Ω–Ω—ã–π —Ç—Ä–µ–Ω–¥'
    else:
        return '–°–∏–ª—å–Ω—ã–π —Ç—Ä–µ–Ω–¥'


===== ./services/coin_rotator.py =====
import time
from typing import List
import logging
from app.services.coin_ranker import CoinRanker
from app.services.coin_selector import CoinSelector


class CoinRotator:
    def __init__(
        self,
        initial_coins: List[str],
        trading_system,  # –°—Å—ã–ª–∫–∞ –Ω–∞ –æ—Å–Ω–æ–≤–Ω—É—é —Ç–æ—Ä–≥–æ–≤—É—é —Å–∏—Å—Ç–µ–º—É
        rotation_interval: int = 86400,
        min_trades_for_eval: int = 5,
        max_inactive_hours: int = 24,
    ):
        self.ranker = CoinRanker(min_trades=min_trades_for_eval)
        self.ranker.add_new_coins(initial_coins)
        self.selector = CoinSelector(initial_coins)
        self.rotation_interval = rotation_interval
        self.max_inactive_hours = max_inactive_hours
        self.last_rotation = 0
        self.last_activity_time = time.time()
        # –£–±—Ä–∞–Ω–æ –¥—É–±–ª–∏—Ä—É—é—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ current_coin - –∏—Å–ø–æ–ª—å–∑—É–µ–º trading_system.current_coin
        self.trading_system = trading_system  # –û—Å–Ω–æ–≤–Ω–∞—è —Ç–æ—Ä–≥–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞
        self.logger = logging.getLogger("coin_rotator")
        self.logger.info(f"‚öôÔ∏è –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω —Ä–æ—Ç–∞—Ç–æ—Ä –¥–ª—è {initial_coins}")

    def rotate_coins(self):
        """–û—Å–Ω–æ–≤–Ω–∞—è –ª–æ–≥–∏–∫–∞ —Ä–æ—Ç–∞—Ü–∏–∏ –º–æ–Ω–µ—Ç"""
        # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é –º–æ–Ω–µ—Ç—É –∏–∑ —Ç–æ—Ä–≥–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã
        previous_coin = self.trading_system.current_coin

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ –æ—Ç–∫—Ä—ã—Ç—ã–µ –ø–æ–∑–∏—Ü–∏–∏ —á–µ—Ä–µ–∑ API
        open_positions = self.trading_system.bybit.get_open_positions()
        if open_positions:
            current_coin = open_positions[0]["coin"]
            if current_coin != self.trading_system.current_coin:
                self.logger.warning(
                    f"‚ö†Ô∏è –û–±–Ω–∞—Ä—É–∂–µ–Ω–æ —Ä–∞—Å—Ö–æ–∂–¥–µ–Ω–∏–µ: API –ø–æ–∑–∏—Ü–∏—è {current_coin} vs —Å–æ—Å—Ç–æ—è–Ω–∏–µ {self.trading_system.current_coin}"
                )
                self.trading_system.switch_coin(current_coin)
            return current_coin  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –º–æ–Ω–µ—Ç—É –æ—Ç–∫—Ä—ã—Ç–æ–π –ø–æ–∑–∏—Ü–∏–∏

        current_time = time.time()
        is_real_rotation = False

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Ä–µ–º—è –±–µ–∑–¥–µ–π—Å—Ç–≤–∏—è
        inactive_hours = (current_time - self.last_activity_time) / 3600
        if inactive_hours > self.max_inactive_hours:
            self.logger.warning(
                f"üïí –ü—Ä–µ–≤—ã—à–µ–Ω–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è –±–µ–∑–¥–µ–π—Å—Ç–≤–∏—è ({inactive_hours:.1f} > {self.max_inactive_hours} —á–∞—Å–æ–≤)"
            )
            is_real_rotation = True

        # –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º —Ä–æ—Ç–∞—Ü–∏—é, –µ—Å–ª–∏ –º–æ–Ω–µ—Ç–∞ "–∑–∞—Å—Ç—Ä—è–ª–∞"
        coin_data = self.ranker.data["active_coins"].get(previous_coin)
        max_selections = 50
        if coin_data and coin_data.get("selections", 0) > max_selections:
            self.logger.warning(
                f"üîÑ –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è —Ä–æ—Ç–∞—Ü–∏—è –¥–ª—è {previous_coin} (–±–æ–ª–µ–µ {max_selections} –≤—ã–±–æ—Ä–æ–≤)"
            )
            is_real_rotation = True

        if (
            current_time - self.last_rotation > self.rotation_interval
            or is_real_rotation
        ):
            # –ü–æ–ª—É—á–∞–µ–º –ª—É—á—à–∏–µ –º–æ–Ω–µ—Ç—ã –∏–∑ —Ä–∞–Ω–∫–µ—Ä–∞
            best_coins = self.ranker.get_best_coins(top_n=5)
            scores = self.selector.evaluate_coins()

            # –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ –º–æ–Ω–µ—Ç
            combined_ranking = {}
            for coin, score in scores:
                combined_ranking[coin] = score * 0.7
            for coin in best_coins:
                combined_ranking[coin] = combined_ranking.get(coin, 0) + 0.3

            best_coin = max(combined_ranking, key=combined_ranking.get)

            # –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
            current_perf = self.ranker.get_coin_performance(previous_coin)
            new_perf = self.ranker.get_coin_performance(best_coin)

            # –£—Å–ª–æ–≤–∏—è —Ä–æ—Ç–∞—Ü–∏–∏
            should_rotate = (
                is_real_rotation
                or new_perf["score"] > current_perf["score"] * 1.5
                or new_perf["score"] >= current_perf["score"]
            )

            if should_rotate and (previous_coin != best_coin or is_real_rotation):
                reason = (
                    "–ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è —Ä–æ—Ç–∞—Ü–∏—è"
                    if inactive_hours > self.max_inactive_hours
                    or coin_data.get("selections", 0) > max_selections
                    else "–ª—É—á—à–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å"
                )
                self.logger.info(
                    f"üîÑ –†–æ—Ç–∞—Ü–∏—è —Å {previous_coin} –Ω–∞ {best_coin} ({reason})"
                )

                # –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –≤ —Ç–æ—Ä–≥–æ–≤–æ–π —Å–∏—Å—Ç–µ–º–µ
                self.trading_system.switch_coin(best_coin)
                self.last_activity_time = time.time()

                # –§–∏–∫—Å–∏—Ä—É–µ–º –≤—ã–±–æ—Ä –ø—Ä–µ–¥—ã–¥—É—â–µ–π –º–æ–Ω–µ—Ç—ã (–¥–∞–∂–µ –µ—Å–ª–∏ —Ä–æ—Ç–∞—Ü–∏—è –Ω–µ —Ä–µ–∞–ª—å–Ω–∞—è, –Ω–æ –º–æ–Ω–µ—Ç–∞ –±—ã–ª–∞ –≤—ã–±—Ä–∞–Ω–∞)
                self.ranker.record_selection(
                    previous_coin, is_real_rotation=is_real_rotation
                )

                # –§–∏–∫—Å–∏—Ä—É–µ–º –≤—ã–±–æ—Ä –Ω–æ–≤–æ–π –º–æ–Ω–µ—Ç—ã
                self.ranker.record_selection(
                    best_coin, is_real_rotation=is_real_rotation
                )

            else:

                # –§–∏–∫—Å–∏—Ä—É–µ–º, —á—Ç–æ –º–æ–Ω–µ—Ç–∞ –±—ã–ª–∞ –≤—ã–±—Ä–∞–Ω–∞ (–¥–∞–∂–µ –±–µ–∑ —Ä–æ—Ç–∞—Ü–∏–∏)
                self.ranker.record_selection(previous_coin, is_real_rotation=False)
                self.logger.info(
                    f"‚è≠Ô∏è –°–æ—Ö—Ä–∞–Ω—è–µ–º {previous_coin}: –Ω–æ–≤–∞—è –º–æ–Ω–µ—Ç–∞ –Ω–µ –ª—É—á—à–µ (—Ç–µ–∫—É—â–∏–π: {current_perf['score']:.2f}, –Ω–æ–≤–∞—è: {new_perf['score']:.2f})"
                )

            self.last_rotation = current_time

        return self.trading_system.current_coin
    
    def set_current_coin(self, coin: str):
        """–£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Ç–µ–∫—É—â—É—é –º–æ–Ω–µ—Ç—É –¥–ª—è —Ä–æ—Ç–∞—Ü–∏–∏"""
        if coin in self.selector.coin_list:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—Ç–∫—Ä—ã—Ç—ã–µ –ø–æ–∑–∏—Ü–∏–∏ —á–µ—Ä–µ–∑ API
            open_positions = self.trading_system.bybit.get_open_positions()
            if open_positions:
                current_coin = open_positions[0]['coin']
                if coin != current_coin:
                    self.logger.warning(f"‚ö†Ô∏è –ö–æ–Ω—Ñ–ª–∏–∫—Ç: –ø–æ–ø—ã—Ç–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å {coin} –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–æ–π –ø–æ–∑–∏—Ü–∏–∏ –ø–æ {current_coin}")
                    return
                    
            self.trading_system.current_coin = coin
            self.last_activity_time = time.time()  # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ç–∞–π–º–µ—Ä –±–µ–∑–¥–µ–π—Å—Ç–≤–∏—è
            self.logger.info(f"‚öôÔ∏è –£—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ —Ç–µ–∫—É—â–∞—è –º–æ–Ω–µ—Ç–∞: {coin}")

    def record_trade_result(self, profit: float):
        """–§–∏–∫—Å–∏—Ä—É–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Å–¥–µ–ª–∫–∏ –≤ —Ä–∞–Ω–∫–µ—Ä–µ"""
        if self.trading_system.current_coin:
            self.ranker.record_trade_result(self.trading_system.current_coin, profit)
            self.last_activity_time = time.time()
            self.logger.info(
                f"üìä –ó–∞–ø–∏—Å–∞–Ω–∞ —Å–¥–µ–ª–∫–∞ –¥–ª—è {self.trading_system.current_coin}: –ø—Ä–∏–±—ã–ª—å = {profit:.4f} USDT"
            )

    def update_activity(self):
        """–û–±–Ω–æ–≤–ª—è–µ—Ç –≤—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏"""
        self.last_activity_time = time.time()


===== ./services/bybit_sync.py =====

from app.config import BYBIT_API_KEY, BYBIT_API_SECRET, IS_TESTNET
from pybit.unified_trading import HTTP
from app.utils.log_helper import log_maker

client = HTTP(
    testnet=IS_TESTNET,
    api_key=BYBIT_API_KEY,
    api_secret=BYBIT_API_SECRET,
    recv_window=15000,
)

def get_order_history(symbol: str, limit: int = 50):
    try:
        response = client.get_order_history(category="spot", symbol=symbol, limit=limit)
        return response["result"]["list"]
    except Exception as e:
        log_maker(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏—Å—Ç–æ—Ä–∏–∏ –æ—Ä–¥–µ—Ä–æ–≤: {e}")
        return []


===== ./services/bot_controller.py =====
import os
import json
import time
import threading
import logging
from app.services.bot_runner import TradingBot
from app.services.bybit_service import BybitService
from app.strategies import NeuralStrategy, MovingAverageStrategy
from app.utils.log_helper import log_maker, log_error

class BotController:
    def __init__(self, strategy_type='neural'):
        self.thread = None
        self.strategy_type = strategy_type
        self._running = threading.Event()
        self.bybit = BybitService()
        self.state = self.load_bot_state()
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –ø–æ–∑–∏—Ü–∏–π —á–µ—Ä–µ–∑ API
        open_positions = self.bybit.get_open_positions()
        if open_positions:
            self.symbol = open_positions[0]['symbol']
            self.position_coin = open_positions[0]['coin']
            log_maker(f"‚ö° –û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ –æ—Ç–∫—Ä—ã—Ç–∞—è –ø–æ–∑–∏—Ü–∏—è: {self.symbol}")
        else:
            self.symbol = self._clean_symbol(self.state.get("current_coin", "SOL"))
            self.position_coin = self.symbol.replace('USDT', '')
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
        self.interval = "5" if strategy_type == 'neural' else "3"
        self.strategy = self._initialize_strategy()
        self.bot = TradingBot(
            strategy=self.strategy,
            symbol=self.symbol, 
            interval=self.interval,
            controller=self
        )
        
        log_maker(f"‚öôÔ∏è –°—Ç—Ä–∞—Ç–µ–≥–∏—è: {type(self.strategy).__name__}, –∏–Ω—Ç–µ—Ä–≤–∞–ª: {self.interval} –º–∏–Ω—É—Ç")
        self.save_bot_state()

    def load_bot_state(self) -> dict:
        """–ó–∞–≥—Ä—É–∂–∞–µ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏–µ –±–æ—Ç–∞ –∏–∑ —Ñ–∞–π–ª–∞"""
        try:
            with open("bot_state.json", "r") as f:
                return json.load(f)
        except:
            return {
                "current_coin": "SOL",
                "symbol": "SOLUSDT",
                "position_coin": "SOL"
            }

    def _clean_symbol(self, symbol_str: str) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–∏–º–≤–æ–ª–∞"""
        base = symbol_str.replace('USDT', '')
        return f"{base}USDT"
    
    def _initialize_strategy(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ç–æ—Ä–≥–æ–≤–æ–π —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏"""
        coin = self.symbol.replace('USDT', '')
        model_base_path = f"models/{coin}_neural_model"
        
        # –í—ã–±–æ—Ä –º–µ–∂–¥—É –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–≤–æ–π –∏ MA —Å—Ç—Ä–∞—Ç–µ–≥–∏–µ–π
        if self.strategy_type != 'neural':
            return MovingAverageStrategy(
                self.symbol, 
                self.interval,
                trading_system=self
            )
        
        try:
            strategy = NeuralStrategy(
                self.symbol, 
                bybit_service=self.bybit,
                model_path=model_base_path,
                trading_system=self,
                interval=self.interval
            )
            log_maker(f"üß† –ù–µ–π—Ä–æ—Å–µ—Ç–µ–≤–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è –∑–∞–≥—Ä—É–∂–µ–Ω–∞ –¥–ª—è {self.symbol}")
            return strategy
        except Exception as e:
            log_error(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–≤–æ–π —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏: {e}")
            log_maker("üîÑ –ò—Å–ø–æ–ª—å–∑—É—é MovingAverage —Å—Ç—Ä–∞—Ç–µ–≥–∏—é –∫–∞–∫ fallback")
            return MovingAverageStrategy(
                self.symbol, 
                self.interval,
                trading_system=self
            )
    
    def save_bot_state(self):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å–∏—Å—Ç–µ–º—ã"""
        state = {
            "current_coin": self.position_coin,
            "symbol": self.symbol,
            "position_coin": self.position_coin
        }
        with open("bot_state.json", "w") as f:
            json.dump(state, f, indent=2)

    def switch_coin(self, new_coin: str):
        """–ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –Ω–∞ –Ω–æ–≤—É—é –º–æ–Ω–µ—Ç—É"""
        log_maker(f"üîÑ –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –Ω–∞ {new_coin}")
        self.position_coin = new_coin
        self.symbol = f"{new_coin}USDT"
        
        # –ü–µ—Ä–µ–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –¥–ª—è –Ω–æ–≤–æ–π –º–æ–Ω–µ—Ç—ã
        self.strategy = self._initialize_strategy()
        
        # –ü–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–∏–µ —Ç–æ—Ä–≥–æ–≤–æ–≥–æ –±–æ—Ç–∞
        self.bot = TradingBot(
            strategy=self.strategy,
            symbol=self.symbol,
            interval=self.interval,
            controller=self
        )
        
        self.save_bot_state()
        log_maker(f"‚úÖ –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–æ –Ω–∞ {new_coin}")

    def start(self):
        """–ó–∞–ø—É—Å–∫ —Ç–æ—Ä–≥–æ–≤–æ–≥–æ –±–æ—Ç–∞"""
        if self.thread and self.thread.is_alive():
            return
        self._running.set()
        self.thread = threading.Thread(target=self._run_bot_loop, daemon=True)
        self.thread.start()
        log_maker("‚ñ∂Ô∏è –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω")

    def stop(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ç–æ—Ä–≥–æ–≤–æ–≥–æ –±–æ—Ç–∞"""
        if self.thread:
            self._running.clear()
            self.thread.join(timeout=5)
        log_maker("‚èπÔ∏è –ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

    def status(self):
        """–°—Ç–∞—Ç—É—Å —Ä–∞–±–æ—Ç—ã –±–æ—Ç–∞"""
        return "running" if self._running.is_set() else "stopped"

    def _run_bot_loop(self):
        """–û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª —Ä–∞–±–æ—Ç—ã –±–æ—Ç–∞"""
        while self._running.is_set():
            try:
                self.bot.run_once()
            except Exception as e:
                log_error(f"üö® –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ –æ—Å–Ω–æ–≤–Ω–æ–º —Ü–∏–∫–ª–µ: {str(e)}")
                time.sleep(60)

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–∞
bot_controller = BotController()

===== ./services/bybit_service.py =====
import os
import json
import time
import traceback
import requests
import numpy as np
import ccxt  # –î–æ–±–∞–≤–ª—è–µ–º –∏–º–ø–æ—Ä—Ç CCXT

from pybit.unified_trading import HTTP
from typing import List, Dict, Optional, Literal
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

from app.utils.log_helper import log_maker
from app.config import IS_TESTNET


class BybitService:
    def __init__(self, api_key=None, api_secret=None):
        self.session = requests.Session()
        self.session.timeout = 60
        self.min_order_cache = {}
        self.api_key = api_key or os.getenv("BYBIT_API_KEY")
        self.api_secret = api_secret or os.getenv("BYBIT_API_SECRET")
        self.recv_window = "5000"

        self.ccxt_exchange = ccxt.bybit(
            {
                "apiKey": self.api_key,
                "secret": self.api_secret,
                "enableRateLimit": True,
                "options": {"defaultType": "spot"},
            }
        )

        self.client = HTTP(
            testnet=IS_TESTNET,
            api_key=self.api_key,
            api_secret=self.api_secret,
            recv_window=15000,
            timeout=10,
        )

        retry_strategy = Retry(
            total=3, backoff_factor=0.5, status_forcelist=[429, 500, 502, 503, 504]
        )
        adapter = HTTPAdapter(max_retries=retry_strategy)
        self.session.mount("https://", adapter)

    def get_candles(self, symbol: str, interval: str, limit: int = 100) -> List[Dict]:
        # –î–ª—è –±–æ–ª—å—à–∏—Ö –ª–∏–º–∏—Ç–æ–≤ –∏—Å–ø–æ–ª—å–∑—É–µ–º CCXT
        if limit > 200:
            return self._get_candles_via_ccxt(symbol, interval, min(limit, 1000))

        cache_key = f"{symbol}_{interval}_{limit}"
        cache_duration = 60 if interval == "15" else 300

        if hasattr(self, "candle_cache") and cache_key in self.candle_cache:
            cached = self.candle_cache[cache_key]
            if time.time() - cached["timestamp"] < cache_duration:
                return cached["data"]

        limit = min(limit, 100)

        url = "https://api.bybit.com/v5/market/kline"
        params = {
            "category": "spot",
            "symbol": symbol,
            "interval": interval,
            "limit": limit,
            "simple": "true",
        }

        for attempt in range(5):
            try:
                start_time = time.time()
                response = self.session.get(url, params=params, timeout=(15, 45))

                duration = time.time() - start_time
                if duration > 3:
                    log_maker(
                        f"‚è±Ô∏è –ó–∞–ø—Ä–æ—Å {symbol} –∑–∞–Ω—è–ª {duration:.2f} —Å–µ–∫ (–ø–æ–ø—ã—Ç–∫–∞ {attempt+1})"
                    )

                if response.status_code != 200:
                    log_maker(f"üìä‚ùå HTTP {response.status_code} –¥–ª—è {symbol}")
                    # –ü–æ–≤—Ç–æ—Ä—è–µ–º –ø–æ–ø—ã—Ç–∫—É –¥–ª—è –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ—à–∏–±–æ–∫
                    if response.status_code in [429, 500, 502, 503, 504]:
                        time.sleep(2**attempt)  # Exponential backoff
                        continue
                    return []  # –î–ª—è –¥—Ä—É–≥–∏—Ö –æ—à–∏–±–æ–∫ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫

                data = response.json()

                if data.get("retCode") != 0:
                    error_msg = data.get("retMsg", "Unknown error")
                    log_maker(f"üìä‚ùå API: {error_msg}")

                    # –ï—Å–ª–∏ —ç—Ç–æ –≤—Ä–µ–º–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞, –ø—Ä–æ–±—É–µ–º —Å–Ω–æ–≤–∞
                    if (
                        "too many requests" in error_msg.lower()
                        or "service unavailable" in error_msg.lower()
                    ):
                        time.sleep(2**attempt)  # Exponential backoff
                        continue
                    return []  # –î–ª—è –¥—Ä—É–≥–∏—Ö –æ—à–∏–±–æ–∫ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫

                candles = []
                for item in data["result"]["list"]:
                    try:
                        candles.append(
                            {
                                "timestamp": int(item[0]),
                                "open": float(item[1]),
                                "high": float(item[2]),
                                "low": float(item[3]),
                                "close": float(item[4]),
                                "volume": float(item[5]),
                            }
                        )
                    except (ValueError, IndexError) as e:
                        log_maker(f"üìä‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ —Å–≤–µ—á–∏: {e}")

                candles = candles[::-1]
                if not hasattr(self, "candle_cache"):
                    self.candle_cache = {}
                self.candle_cache[cache_key] = {
                    "data": candles,
                    "timestamp": time.time(),
                }

                return candles

            except (
                requests.exceptions.Timeout,
                requests.exceptions.ConnectionError,
            ) as e:
                wait_time = min(2**attempt, 10)
                log_maker(
                    f"üìä‚ö†Ô∏è –°–µ—Ç–µ–≤–∞—è –æ—à–∏–±–∫–∞ ({attempt+1}): {type(e).__name__} - –∂–¥—É {wait_time} —Å–µ–∫"
                )
                time.sleep(wait_time)
            except Exception as e:
                error_type = type(e).__name__
                log_maker(f"üìäüî• –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ ({error_type}): {str(e)}")
                if attempt == 4:
                    break

        if hasattr(self, "candle_cache") and cache_key in self.candle_cache:
            log_maker(f"üìä‚ö†Ô∏è –ò—Å–ø–æ–ª—å–∑—É—é –∫—ç—à –¥–ª—è {symbol}")
            return self.candle_cache[cache_key]["data"]

        log_maker("üìä‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–≤–µ—á–∏, –≤–æ–∑–≤—Ä–∞—â–∞—é –ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫")
        return []

    def _get_candles_via_ccxt(
        self, symbol: str, interval: str, limit: int
    ) -> List[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–≤–µ—á–µ–π —á–µ—Ä–µ–∑ CCXT (–¥–æ 1000 —Å–≤–µ—á–µ–π)"""
        try:
            # –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–≤
            interval_map = {
                "1": "1m",
                "3": "3m",
                "5": "5m",
                "15": "15m",
                "30": "30m",
                "60": "1h",
                "120": "2h",
                "240": "4h",
                "360": "6h",
                "720": "12h",
                "D": "1d",
                "W": "1w",
                "M": "1M",
            }
            ccxt_interval = interval_map.get(interval, interval)

            log_maker(f"üìä –ó–∞–ø—Ä–æ—Å CCXT: {symbol} {ccxt_interval} x{limit}")
            ohlcv = self.ccxt_exchange.fetch_ohlcv(symbol, ccxt_interval, limit=limit)

            candles = []
            for candle in ohlcv:
                candles.append(
                    {
                        "timestamp": candle[0],
                        "open": candle[1],
                        "high": candle[2],
                        "low": candle[3],
                        "close": candle[4],
                        "volume": candle[5],
                    }
                )

            log_maker(f"üìä –ü–æ–ª—É—á–µ–Ω–æ {len(candles)} —Å–≤–µ—á–µ–π —á–µ—Ä–µ–∑ CCXT")
            return candles
        except Exception as e:
            log_maker(f"üî• CCXT –æ—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–≤–µ—á–µ–π: {str(e)}")
            return []

    # –û—Å—Ç–∞–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
    def get_price(self, symbol: str) -> float | None:
        try:
            url = "https://api.bybit.com/v5/market/tickers"
            params = {"category": "spot", "symbol": symbol}
            response = requests.get(url, params=params, timeout=5)
            data = response.json()
            return float(data["result"]["list"][0]["lastPrice"])
        except Exception as e:
            log_maker(f"üí• [ERROR] –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ü–µ–Ω—ã: {e}")
            return None

    def market_order(
        self, symbol: str, side: str, quantity: float, is_quote: bool = False
    ) -> dict:
        try:
            params = {
                "category": "spot",
                "symbol": symbol,
                "side": side.capitalize(),
                "orderType": "Market",
            }

            if side.lower() == "buy" and is_quote:
                params["marketUnit"] = "quoteCoin"
                quantity = round(quantity, 2)
                params["qty"] = str(quantity)
            else:
                params["qty"] = str(quantity)

            response = self.client.place_order(**params)
            return response
        except Exception as e:
            log_maker(f"üö´ [ERROR] –û—à–∏–±–∫–∞ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –æ—Ä–¥–µ—Ä–∞: {e}")
            return {}

    def get_balance(self, coin: str, retries: int = 3) -> float:
        for attempt in range(retries):
            try:
                data = self.client.get_wallet_balance(accountType="UNIFIED", coin=coin)
                coin_info = data["result"]["list"][0]["coin"]
                for item in coin_info:
                    if item["coin"] == coin:
                        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø—É—Å—Ç—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
                        value = item.get("availableToTrade") or \
                                item.get("availableBalance") or \
                                item.get("walletBalance")
                        
                        # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–ª—É—á–∞–∏ —Å –ø—É—Å—Ç–æ–π —Å—Ç—Ä–æ–∫–æ–π
                        if value == '':
                            return 0.0
                        return float(value) if value else 0.0
                return 0.0
            except Exception as e:
                if attempt < retries - 1:
                    time.sleep(1.5 ** attempt)
                else:
                    log_maker(f"üí∞‚ùå [ERROR] –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞: {e}")
        return 0.0

    def get_filled_orders(self, symbol: str, limit: int = 5) -> list[dict]:
        try:
            response = self.client.get_order_history(
                category="spot", symbol=symbol, limit=limit, orderStatus="Filled"
            )
            orders = response["result"]["list"]

            return sorted(orders, key=lambda x: int(x["createdTime"]), reverse=True)
        except Exception as e:
            log_maker(f"üìú‚ùå [ERROR] –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é –æ—Ä–¥–µ—Ä–æ–≤: {e}")
            return []

    def get_last_filled_price(self, symbol: str) -> float | None:
        orders = self.get_filled_orders(symbol)
        if not orders:
            return None
        return float(orders[0]["avgPrice"])

    def get_qty_precision(self, symbol: str) -> int:
        try:
            url = "https://api.bybit.com/v5/market/instruments-info"
            params = {"category": "spot", "symbol": symbol}
            resp = requests.get(url, params=params, timeout=10)
            data = resp.json()
            base_precision = data["result"]["list"][0]["lotSizeFilter"]["basePrecision"]

            if "." in base_precision:
                decimal_part = base_precision.split(".")[1]
                decimal_places = len(decimal_part.rstrip("0"))
            else:
                decimal_places = 0

            return decimal_places
        except Exception as e:
            log_maker(f"üìè‚ö†Ô∏è [ERROR] –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–æ—á–Ω–æ—Å—Ç–∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞: {e}")
            return 4

    def get_price_precision(self, symbol: str) -> int:
        try:
            url = "https://api.bybit.com/v5/market/instruments-info"
            params = {"category": "spot", "symbol": symbol}
            resp = requests.get(url, params=params, timeout=10)
            data = resp.json()
            price_filter = data["result"]["list"][0]["priceFilter"]
            tick_size = price_filter["tickSize"]
            decimal_places = len(tick_size.split(".")[-1].rstrip("0"))
            return decimal_places
        except Exception as e:
            log_maker(f"üéØ‚ö†Ô∏è [ERROR] –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–æ—á–Ω–æ—Å—Ç–∏ —Ü–µ–Ω—ã: {e}")
            return 4

    def get_order_by_id(self, symbol: str, order_id: str) -> dict | None:
        try:
            orders = self.client.get_order_history(category="spot", symbol=symbol)[
                "result"
            ]["list"]
            for order in orders:
                if order["orderId"] == order_id:
                    return order
        except Exception as e:
            log_maker(f"üÜî‚ùå [ERROR] –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –æ—Ä–¥–µ—Ä –ø–æ ID: {e}")
        return None

    def get_last_filled_order(self, symbol: str, limit=1) -> dict:
        try:
            response = self.client.get_order_history(
                category="spot", symbol=symbol, limit=limit, orderStatus="Filled"
            )
            with open("last_filled_orders_full.json", "w") as f:
                json.dump(response, f, indent=2)

            if response["retCode"] != 0:
                return None

            orders = response["result"]["list"]
            if not orders:
                return None

            return {
                "symbol": orders[0]["symbol"],
                "side": orders[0]["side"],
                "qty": orders[0]["qty"],
                "cumExecValue": orders[0]["cumExecValue"],
                "cumExecFee": orders[0]["cumExecFee"],
                "cumExecQty": orders[0]["cumExecQty"],
                "avg_price": orders[0]["avgPrice"],
                "timestamp": int(orders[0]["createdTime"]),
                "order_id": orders[0]["orderId"],
            }
        except Exception as e:
            log_maker(f"üî• –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê –ø–æ–ª—É—á–µ–Ω–∏—è –æ—Ä–¥–µ—Ä–∞: {e}")
            return None

    def get_min_order_qty(self, symbol: str) -> float:
        if symbol in self.min_order_cache:
            cached = self.min_order_cache[symbol]
            if time.time() - cached["timestamp"] < 3600:
                return cached["value"]

        try:
            url = "https://api.bybit.com/v5/market/instruments-info"
            params = {"category": "spot", "symbol": symbol}
            resp = requests.get(url, params=params, timeout=10)
            data = resp.json()

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –¥–∞–Ω–Ω—ã—Ö
            if (
                not data.get("result")
                or not data["result"].get("list")
                or len(data["result"]["list"]) == 0
            ):
                return 0.001  # –ó–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é

            min_order_qty = float(
                data["result"]["list"][0]["lotSizeFilter"]["minOrderQty"]
            )

            self.min_order_cache[symbol] = {
                "value": min_order_qty,
                "timestamp": time.time(),
            }
            return min_order_qty
        except Exception as e:
            log_maker(f"üìè‚ö†Ô∏è [ERROR] –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞: {e}")
            return 0.001  # –ó–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é

    def validate_price(self, price: float, symbol: str) -> bool:
        if price is None or price < 0.1 or price > 100000:
            return False

        current_price = self.get_price(symbol)
        if current_price is None:
            return False

        price_diff = abs(price - current_price) / current_price
        return price_diff < 0.1

    def get_reliable_price(self, symbol: str) -> float:
        prices = []
        for _ in range(3):
            price = self.get_price(symbol)
            if price:
                prices.append(price)
            time.sleep(0.1)

        if not prices:
            log_maker("üö® –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –Ω–∞–¥–µ–∂–Ω—É—é —Ü–µ–Ω—É")
            return 0.0

        return float(np.median(prices))

    def get_best_bid_ask(
        self, symbol: str
    ) -> tuple[float | Literal[0], float | Literal[0]] | tuple[Literal[0], Literal[0]]:
        try:
            url = "https://api.bybit.com/v5/market/orderbook"
            params = {"category": "spot", "symbol": symbol, "limit": 1}
            response = requests.get(url, params=params, timeout=5)
            data = response.json()

            if data["retCode"] == 0:
                orderbook = data["result"]
                best_bid = float(orderbook["b"][0][0]) if orderbook.get("b") else 0
                best_ask = float(orderbook["a"][0][0]) if orderbook.get("a") else 0
                return best_bid, best_ask
        except Exception as e:
            log_maker(f"üìä‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞–∫–∞–Ω–∞: {e}")
        return 0, 0

    def get_open_positions(self) -> list:
        try:
            response = self.client.get_wallet_balance(accountType="UNIFIED")
            coins = response["result"]["list"][0]["coin"]
            return [
                {
                    'symbol': f"{item['coin']}USDT",
                    'coin': item['coin'],
                    'size': float(item['availableToWithdraw']) if item['availableToWithdraw'] != '' else 0.0,
                    'avg_price': 0.0
                }
                for item in coins
                if float(item['availableToWithdraw'] or 0) > 0 and item['coin'] != 'USDT'
            ]

        except Exception as e:
            log_maker(f"üî• –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏–π: {str(e)}")
            return []

    def get_last_filled_order_for_coin(self, coin: str) -> Optional[dict]:
        """–ü–æ–ª—É—á–∞–µ—Ç –ø–æ—Å–ª–µ–¥–Ω–∏–π –∏—Å–ø–æ–ª–Ω–µ–Ω–Ω—ã–π –æ—Ä–¥–µ—Ä –¥–ª—è –º–æ–Ω–µ—Ç—ã —á–µ—Ä–µ–∑ API"""
        symbol = f"{coin}USDT"
        try:
            response = self.client.get_order_history(
                category="spot", symbol=symbol, limit=1, orderStatus="Filled"
            )

            if response["retCode"] != 0:
                return None

            orders = response["result"]["list"]
            if not orders:
                return None

            order = orders[0]
            return {
                "symbol": order["symbol"],
                "side": order["side"],
                "qty": float(order["qty"]),
                "price": float(order["avgPrice"]),
                "timestamp": int(order["createdTime"]),
            }
        except Exception as e:
            log_maker(f"üî• –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –æ—Ä–¥–µ—Ä–∞: {e}")
            return None


===== ./services/bot_runner.py =====
import time
import traceback
from app.trading.data_provider import DataProvider
from app.trading.order_executor import OrderExecutor
from app.utils.log_helper import log_maker
from app.utils.candle_sync import CandleSynchronizer

class TradingBot:
    def __init__(self, strategy, symbol: str, interval: str, controller=None):
        self.symbol = symbol
        self.interval = int(interval)
        self.strategy = strategy
        self.controller = controller
        self.data_provider = DataProvider(symbol, interval)
        if controller:
            self.data_provider.controller = controller
        self.order_executor = OrderExecutor(symbol)
        self.synchronizer = CandleSynchronizer(self.interval)
        self._running = False
        self.first_run = True
        log_maker(f"ü§ñ –¢–æ—Ä–≥–æ–≤—ã–π –±–æ—Ç –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω –¥–ª—è {symbol}")
        log_maker(f"  ‚Ä¢ –°—Ç—Ä–∞—Ç–µ–≥–∏—è: {type(strategy).__name__}")
        log_maker(f"  ‚Ä¢ –ò–Ω—Ç–µ—Ä–≤–∞–ª: {interval} –º–∏–Ω—É—Ç")
        log_maker(f"  ‚Ä¢ –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å–æ —Å–≤–µ—á–∞–º–∏: –≤–∫–ª—é—á–µ–Ω–∞")

    def run_once(self):
        start_time = time.time()
        try:
            # –û–±–Ω–æ–≤–ª—è–µ–º –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å —Ä–æ—Ç–∞—Ç–æ—Ä–∞
            if hasattr(self.strategy, 'rotator'):
                self.strategy.rotator.update_activity()
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏ —á–µ—Ä–µ–∑ API
            open_positions = self.order_executor.bybit.get_open_positions()
            if open_positions:
                current_coin = open_positions[0]['coin']
                if current_coin != self.symbol.replace('USDT', ''):
                    log_maker(f"üîÑ –û–±–Ω–∞—Ä—É–∂–µ–Ω–æ —Ä–∞—Å—Ö–æ–∂–¥–µ–Ω–∏–µ: –ø–æ–∑–∏—Ü–∏—è {current_coin} vs –±–æ—Ç {self.symbol}")
                    self.controller.switch_coin(current_coin)
                    return  # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Ü–∏–∫–ª –¥–ª—è –ø–µ—Ä–µ–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
            
            # –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å–æ —Å–≤–µ—á–∞–º–∏
            sleep_time = self.synchronizer.time_until_next_candle()
            max_wait = 60 if self.first_run else 300
            self.first_run = False
            
            if sleep_time > 1:
                actual_wait = min(sleep_time, max_wait)
                if actual_wait > 5:
                    log_maker(f"‚è± –û–∂–∏–¥–∞–Ω–∏–µ —Å–≤–µ—á–∏: {actual_wait:.1f} —Å–µ–∫")
                time.sleep(actual_wait)
            
            # –ü–æ–ª—É—á–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–æ–≤
            coin = self.symbol.replace("USDT", "")
            usdt_balance = self.order_executor.bybit.get_balance("USDT")
            coin_balance = self.order_executor.bybit.get_balance(coin)
            log_maker(f"üí∞ –ë–∞–ª–∞–Ω—Å: {usdt_balance:.2f} USDT, {coin_balance:.4f} {coin}")
            
            # –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
            candles = self.data_provider.get_candles(limit=100)
            
            if not candles or len(candles) < 10:
                log_maker(f"‚õî –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö: {len(candles)} —Å–≤–µ—á–µ–π")
                return
                
            # –ê–Ω–∞–ª–∏–∑ –∏ —Ç–æ—Ä–≥–æ–≤–ª—è
            action = self.strategy.should_trade(candles)
            
            if action:
                log_maker(f"‚ö° –°–∏–≥–Ω–∞–ª: {action}")
                self.strategy.execute_trade(action, self.order_executor)
                
        except Exception as e:
            log_maker(f"üí• –û—à–∏–±–∫–∞: {type(e).__name__} - {str(e)}")
            traceback.print_exc()
        finally:
            total_duration = time.time() - start_time
            log_maker(f"‚è± –¶–∏–∫–ª –∑–∞–≤–µ—Ä—à–µ–Ω –∑–∞ {total_duration:.2f} —Å–µ–∫")
            time.sleep(max(10, self.interval * 60 - total_duration))
            
    def start(self):
        self._running = True
        log_maker(f"‚ñ∂Ô∏è [BOT] –ó–∞–ø—É—â–µ–Ω ({type(self.strategy).__name__} —Å—Ç—Ä–∞—Ç–µ–≥–∏—è)")
        while self._running:
            self.run_once()

    def stop(self):
        self._running = False
        log_maker("‚èπÔ∏è [BOT] –û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

===== ./services/coin_ranker.py =====
import os
import json
import time
import numpy as np
from datetime import datetime, timedelta
import logging
from typing import Dict, List, Tuple, Optional


class CoinRanker:
    def __init__(self, data_path: str = "data/coin_ranking.json", min_trades: int = 5):
        self.data_path = data_path
        self.min_trades = min_trades
        self.logger = logging.getLogger("coin_ranker")
        self.logger.setLevel(logging.INFO)

        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ü–ï–†–ï–î –∑–∞–≥—Ä—É–∑–∫–æ–π –¥–∞–Ω–Ω—ã—Ö
        self.default_settings = {
            "trial_period": 10,
            "min_success_rate": 0.5,
            "min_avg_profit": 0.005,
            "evaluation_period": 30,
            "initial_boost": 2,
            "decay_factor": 0.95,
            "max_coins": 30,
            "min_trade_density": 0.3,
        }

        # –¢–µ–ø–µ—Ä—å –∑–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ
        self.data = self.load_data()

        # –û–±–Ω–æ–≤–ª—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
        if "settings" not in self.data:
            self.data["settings"] = self.default_settings
        else:
            for key, value in self.default_settings.items():
                if key not in self.data["settings"]:
                    self.data["settings"][key] = value

        os.makedirs("logs", exist_ok=True)

    def get_best_coins(self, top_n: int = 5) -> List[str]:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ª—É—á—à–∏–µ –º–æ–Ω–µ—Ç—ã –ø–æ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏"""
        ranked = self.get_ranked_coins()
        return [coin for coin, _ in ranked[:top_n]]

    def load_data(self) -> Dict:
        """–ó–∞–≥—Ä—É–∂–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –∏–∑ —Ñ–∞–π–ª–∞ —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –∫–æ—Ä—Ä–µ–∫—Ü–∏–µ–π"""
        os.makedirs(os.path.dirname(self.data_path), exist_ok=True)

        if os.path.exists(self.data_path):
            try:
                with open(self.data_path, "r") as f:
                    data = json.load(f)
                    # –î–æ–±–∞–≤–ª—è–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫—É—é –º–∏–≥—Ä–∞—Ü–∏—é —Å—Ç–∞—Ä—ã—Ö –¥–∞–Ω–Ω—ã—Ö
                    self._migrate_old_data(data)
                    # –ü—Ä–∏–º–µ–Ω—è–µ–º –∫–æ—Ä—Ä–µ–∫—Ü–∏—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
                    self.fix_statistics(data)
                    return data
            except Exception as e:
                self.logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö: {e}")
                return self._create_initial_data()
        return self._create_initial_data()

    def _migrate_old_data(self, data: dict):
        """–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç —Å—Ç–∞—Ä—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã –¥–∞–Ω–Ω—ã—Ö –≤ –Ω–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç"""
        # –ú–∏–≥—Ä–∞—Ü–∏—è –¥–ª—è active_coins
        for coin, coin_data in data.get("active_coins", {}).items():
            # –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è timestamp –≤ ISO —Å—Ç—Ä–æ–∫—É
            if "first_selected" in coin_data and isinstance(
                coin_data["first_selected"], (int, float)
            ):
                coin_data["first_selected"] = datetime.fromtimestamp(
                    coin_data["first_selected"]
                ).isoformat()

            if "last_selected" in coin_data and isinstance(
                coin_data["last_selected"], (int, float)
            ):
                coin_data["last_selected"] = datetime.fromtimestamp(
                    coin_data["last_selected"]
                ).isoformat()

        # –ú–∏–≥—Ä–∞—Ü–∏—è –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        stats = data.get("statistics", {})
        if "last_rotation" in stats and isinstance(
            stats["last_rotation"], (int, float)
        ):
            stats["last_rotation"] = datetime.fromtimestamp(
                stats["last_rotation"]
            ).isoformat()

        if "created_at" in stats and isinstance(stats["created_at"], (int, float)):
            stats["created_at"] = datetime.fromtimestamp(
                stats["created_at"]
            ).isoformat()

    def fix_statistics(self, data: dict):
        """–ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ—Ç –∏—Å–∫–∞–∂–µ–Ω–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É selections"""
        for coin, coin_data in data.get("active_coins", {}).items():
            try:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∏–ø –¥–∞–Ω–Ω—ã—Ö –¥–ª—è first_selected
                first_selected = coin_data["first_selected"]
                if not isinstance(first_selected, str):
                    # –ï—Å–ª–∏ —ç—Ç–æ timestamp, –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ —Å—Ç—Ä–æ–∫—É
                    if isinstance(first_selected, (int, float)):
                        coin_data["first_selected"] = datetime.fromtimestamp(
                            first_selected
                        ).isoformat()
                    else:
                        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–µ–∫—É—â—É—é –¥–∞—Ç—É –∫–∞–∫ fallback
                        coin_data["first_selected"] = datetime.now().isoformat()
                        self.logger.warning(f"üõ†Ô∏è –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ first_selected –¥–ª—è {coin}")

                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–∏–ø –¥–∞–Ω–Ω—ã—Ö –¥–ª—è last_selected
                last_selected = coin_data["last_selected"]
                if not isinstance(last_selected, str):
                    # –ï—Å–ª–∏ —ç—Ç–æ timestamp, –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ —Å—Ç—Ä–æ–∫—É
                    if isinstance(last_selected, (int, float)):
                        coin_data["last_selected"] = datetime.fromtimestamp(
                            last_selected
                        ).isoformat()
                    else:
                        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–µ–∫—É—â—É—é –¥–∞—Ç—É –∫–∞–∫ fallback
                        coin_data["last_selected"] = datetime.now().isoformat()
                        self.logger.warning(f"üõ†Ô∏è –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ last_selected –¥–ª—è {coin}")

                # –¢–µ–ø–µ—Ä—å –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Å—Ç—Ä–æ–∫–∏ –≤ datetime –æ–±—ä–µ–∫—Ç—ã
                first = datetime.fromisoformat(coin_data["first_selected"])
                last = datetime.fromisoformat(coin_data["last_selected"])
                days_active = (last - first).days + 1

                # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º selections –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –¥–Ω–µ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
                if coin_data["selections"] > days_active:
                    self.logger.info(
                        f"üõ†Ô∏è –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º selections –¥–ª—è {coin}: {coin_data['selections']} -> {days_active}"
                    )
                    coin_data["selections"] = days_active

                    # –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º trial_used
                    trial_period = data["settings"]["trial_period"]
                    coin_data["trial_used"] = min(coin_data["trial_used"], trial_period)
            except Exception as e:
                self.logger.error(f"–û—à–∏–±–∫–∞ –∫–æ—Ä—Ä–µ–∫—Ü–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –¥–ª—è {coin}: {e}")
                # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –ø—Ä–∏ –Ω–µ—É–¥–∞—á–Ω–æ–π –∫–æ—Ä—Ä–µ–∫—Ü–∏–∏
                coin_data["first_selected"] = datetime.now().isoformat()
                coin_data["last_selected"] = datetime.now().isoformat()
                coin_data["selections"] = 1
                coin_data["trial_used"] = 0

    def _create_initial_data(self) -> Dict:
        return {
            "active_coins": {},
            "archived_coins": {},
            "statistics": {
                "total_rotations": 0,
                "last_rotation": None,
                "created_at": datetime.now().isoformat(),
            },
            "settings": self.default_settings,  # –∏—Å–ø–æ–ª—å–∑—É–µ–º self.default_settings
        }

    def save_data(self):
        """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –¥–∞–Ω–Ω—ã–µ –≤ —Ñ–∞–π–ª"""
        try:
            with open(self.data_path, "w") as f:
                json.dump(self.data, f, indent=2)
        except Exception as e:
            self.logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö: {e}")

    def add_new_coin(self, coin: str):
        """–î–æ–±–∞–≤–ª—è–µ—Ç –Ω–æ–≤—É—é –º–æ–Ω–µ—Ç—É –≤ —Å–∏—Å—Ç–µ–º—É –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è"""
        if coin in self.data["active_coins"] or coin in self.data["archived_coins"]:
            return

        if len(self.data["active_coins"]) >= self.data["settings"]["max_coins"]:
            self._remove_lowest_performer()

        self.data["active_coins"][coin] = {
            "selections": 0,  # –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤—ã–±–æ—Ä–æ–≤ (–∏—Ç–µ—Ä–∞—Ü–∏–π)
            "trades": 0,  # –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–¥–µ–ª–æ–∫
            "profitable_trades": 0,
            "total_profit": 0.0,
            "last_selected": None,
            "first_selected": datetime.now().isoformat(),
            "last_trade": None,
            "trial_used": 0,
            "performance_score": 0.0,
            "priority": 1.0,  # –ù–∞—á–∞–ª—å–Ω—ã–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç
        }
        self.logger.info(f"–î–æ–±–∞–≤–ª–µ–Ω–∞ –Ω–æ–≤–∞—è –º–æ–Ω–µ—Ç–∞: {coin}")
        self.save_data()

    def add_new_coins(self, new_coins: List[str]):
        """–î–æ–±–∞–≤–ª—è–µ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ –Ω–æ–≤—ã—Ö –º–æ–Ω–µ—Ç"""
        for coin in new_coins:
            self.add_new_coin(coin)

    def record_selection(self, coin: str, is_real_rotation: bool = False):
        """–§–∏–∫—Å–∏—Ä—É–µ—Ç –≤—ã–±–æ—Ä –º–æ–Ω–µ—Ç—ã (–∏—Ç–µ—Ä–∞—Ü–∏—é)"""
        if coin in self.data["active_coins"]:
            coin_data = self.data["active_coins"][coin]
            # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º selections –í–°–ï–ì–î–ê –ø—Ä–∏ –≤—ã–∑–æ–≤–µ (–Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç —Ä–µ–∞–ª—å–Ω–æ–π —Ä–æ—Ç–∞—Ü–∏–∏)
            coin_data["selections"] += 1

            # –£–º–µ–Ω—å—à–∞–µ–º "–±—É—Å—Ç" —Ç–æ–ª—å–∫–æ –ø—Ä–∏ —Ä–µ–∞–ª—å–Ω–æ–π —Ä–æ—Ç–∞—Ü–∏–∏
            if (
                is_real_rotation
                and coin_data["trial_used"] < self.data["settings"]["trial_period"]
            ):
                coin_data["trial_used"] += 1
                # –ü–ª–∞–≤–Ω–æ–µ —É–º–µ–Ω—å—à–µ–Ω–∏–µ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞ –≤–º–µ—Å—Ç–æ —Ä–µ–∑–∫–æ–≥–æ
                decay = 1.0 - (0.5 / self.data["settings"]["trial_period"])
                coin_data["priority"] *= decay
                self.logger.info(
                    f"üîß {coin}: —É–º–µ–Ω—å—à–µ–Ω –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç (trial {coin_data['trial_used']}/{self.data['settings']['trial_period']})"
                )
            coin_data["last_selected"] = datetime.now().isoformat()
            self.data["statistics"]["total_rotations"] += 1
            self.data["statistics"]["last_rotation"] = datetime.now().isoformat()
            self.save_data()

    def record_trade_result(self, coin: str, profit: float):
        """–ó–∞–ø–∏—Å—ã–≤–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Å–¥–µ–ª–∫–∏"""
        if coin in self.data["active_coins"]:
            coin_data = self.data["active_coins"][coin]
            coin_data["trades"] += 1
            coin_data["last_trade"] = datetime.now().isoformat()

            if profit > 0:
                coin_data["profitable_trades"] += 1

            coin_data["total_profit"] += profit
            self.save_data()

            # –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º –æ—Ü–µ–Ω–∫—É –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
            self._update_performance_score(coin)

            self.logger.info(f"–ó–∞–ø–∏—Å–∞–Ω–∞ —Å–¥–µ–ª–∫–∞ –¥–ª—è {coin}: –ø—Ä–∏–±—ã–ª—å={profit:.2f} USDT")

    def _update_performance_score(self, coin: str):
        """–û–±–Ω–æ–≤–ª—è–µ—Ç –æ—Ü–µ–Ω–∫—É –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –º–æ–Ω–µ—Ç—ã —Å –≥–∞—Ä–∞–Ω—Ç–∏–µ–π –¥–ª—è –Ω–æ–≤—ã—Ö"""
        coin_data = self.data["active_coins"][coin]
        trades = coin_data["trades"]
        selections = coin_data["selections"]

        # –ë–∞–∑–æ–≤—ã–π —Ä–∞—Å—á–µ—Ç –¥–ª—è –º–æ–Ω–µ—Ç —Å –∏—Å—Ç–æ—Ä–∏–µ–π
        if trades > 0:
            success_rate = coin_data["profitable_trades"] / trades
            avg_profit = coin_data["total_profit"] / trades
            score = success_rate * avg_profit * 100
        # –ù–æ–≤—ã–µ –º–æ–Ω–µ—Ç—ã –±–µ–∑ –∏—Å—Ç–æ—Ä–∏–∏ —Å–¥–µ–ª–æ–∫
        else:
            # –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Å—Ç–∞—Ä—Ç–æ–≤—ã–π –±–∞–ª–ª –≤–º–µ—Å—Ç–æ 0
            score = 0.5

            # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –±—É—Å—Ç –¥–ª—è —Å–æ–≤–µ—Ä—à–µ–Ω–Ω–æ –Ω–æ–≤—ã—Ö –º–æ–Ω–µ—Ç
            if coin_data["selections"] == 0:
                score += 1.0

        # –ü—Ä–∏–º–µ–Ω—è–µ–º –±—É—Å—Ç –¥–ª—è –Ω–æ–≤—ã—Ö –º–æ–Ω–µ—Ç
        trial_period = self.data["settings"]["trial_period"]
        if coin_data["trial_used"] < trial_period:
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –±–æ–ª–µ–µ —Å–∏–ª—å–Ω—ã–π –±—É—Å—Ç –Ω–∞ –≤–µ—Å—å –∏—Å–ø—ã—Ç–∞—Ç–µ–ª—å–Ω—ã–π –ø–µ—Ä–∏–æ–¥
            boost = self.data["settings"]["initial_boost"]
            score *= boost

            # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –±—É—Å—Ç –¥–ª—è –ø–µ—Ä–≤—ã—Ö 3 –≤—ã–±–æ—Ä–æ–≤
            if coin_data["selections"] < 3:
                score *= 1.5

        coin_data["performance_score"] = max(0.1, score)  # –ù–∏–∫–æ–≥–¥–∞ –Ω–µ –æ–ø—É—Å–∫–∞–µ–º –Ω–∏–∂–µ 0.1
        self.save_data()

    def get_coin_performance(self, coin: str) -> Dict:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –º–æ–Ω–µ—Ç—ã"""
        if coin not in self.data["active_coins"]:
            return {"status": "unknown", "score": 0, "priority": 0}

        coin_data = self.data["active_coins"][coin]
        return {
            "status": self._get_performance_status(coin_data),
            "score": coin_data["performance_score"],
            "priority": coin_data["priority"],
            "trades": coin_data["trades"],
            "selections": coin_data["selections"],
            "trade_density": (
                coin_data["trades"] / coin_data["selections"]
                if coin_data["selections"] > 0
                else 0
            ),
            "success_rate": (
                coin_data["profitable_trades"] / coin_data["trades"]
                if coin_data["trades"] > 0
                else 0
            ),
            "avg_profit": (
                coin_data["total_profit"] / coin_data["trades"]
                if coin_data["trades"] > 0
                else 0
            ),
        }

    def _get_performance_status(self, coin_data: Dict) -> str:
        """–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Å—Ç–∞—Ç—É—Å –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏"""
        trades = coin_data["trades"]

        if trades == 0:
            return "untested"

        if coin_data["trial_used"] < self.data["settings"]["trial_period"]:
            return "trial"

        success_rate = coin_data["profitable_trades"] / trades
        avg_profit = coin_data["total_profit"] / trades

        if (
            success_rate >= 0.7
            and avg_profit >= self.data["settings"]["min_avg_profit"]
        ):
            return "excellent"
        elif (
            success_rate >= 0.6
            and avg_profit >= self.data["settings"]["min_avg_profit"] * 0.8
        ):
            return "good"
        elif success_rate >= 0.5:
            return "neutral"
        else:
            return "poor"

    def get_ranked_coins(self) -> List[Tuple[str, float]]:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫ –º–æ–Ω–µ—Ç –ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—É"""
        ranked = []
        for coin, data in self.data["active_coins"].items():
            # –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–µ–π—Ç–∏–Ω–≥ = –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å * –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç
            score = data["performance_score"] * data["priority"]
            ranked.append((coin, score))

        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —É–±—ã–≤–∞–Ω–∏—é —Ä–µ–π—Ç–∏–Ω–≥–∞
        ranked.sort(key=lambda x: x[1], reverse=True)
        return ranked

    def should_keep_coin(self, coin: str) -> bool:
        """–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç, —Å—Ç–æ–∏—Ç –ª–∏ —Å–æ—Ö—Ä–∞–Ω—è—Ç—å –º–æ–Ω–µ—Ç—É"""
        perf = self.get_coin_performance(coin)
        return perf["status"] in ["excellent", "good", "trial"]

    def evaluate_and_cleanup(self):
        """–û—Ü–µ–Ω–∏–≤–∞–µ—Ç –∏ –æ—á–∏—â–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –º–æ–Ω–µ—Ç, —É–¥–∞–ª—è—è –Ω–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–µ"""
        coins_to_remove = []

        for coin, data in list(self.data["active_coins"].items()):
            # –£–¥–∞–ª—è–µ–º –º–æ–Ω–µ—Ç—ã —Å –ø–ª–æ—Ö–æ–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é –ø–æ—Å–ª–µ –∏—Å–ø—ã—Ç–∞—Ç–µ–ª—å–Ω–æ–≥–æ —Å—Ä–æ–∫–∞
            if data["trial_used"] >= self.data["settings"]["trial_period"]:
                perf_status = self._get_performance_status(data)
                if perf_status == "poor":
                    coins_to_remove.append(coin)

            # –£–¥–∞–ª—è–µ–º –º–æ–Ω–µ—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ –≤—ã–±–∏—Ä–∞–ª–∏—Å—å –¥–æ–ª–≥–æ–µ –≤—Ä–µ–º—è
            if data["last_selected"]:
                last_selected = datetime.fromisoformat(data["last_selected"])
                if (datetime.now() - last_selected) > timedelta(days=30):
                    coins_to_remove.append(coin)

        for coin in coins_to_remove:
            self.logger.info(
                f"–£–¥–∞–ª–µ–Ω–∏–µ –º–æ–Ω–µ—Ç—ã {coin} –∏–∑-–∑–∞ –ø–ª–æ—Ö–æ–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∏–ª–∏ –Ω–µ–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏"
            )
            self.data["archived_coins"][coin] = self.data["active_coins"].pop(coin)

        if coins_to_remove:
            self.save_data()

    def get_next_coin(self, current_coin: str) -> str:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ª–µ–¥—É—é—â—É—é –º–æ–Ω–µ—Ç—É –¥–ª—è —Ç–æ—Ä–≥–æ–≤–ª–∏"""
        ranked_coins = self.get_ranked_coins()

        # –ï—Å–ª–∏ —Ç–µ–∫—É—â–∞—è –º–æ–Ω–µ—Ç–∞ –≤ —Ç–æ–ø–µ, —Å–æ—Ö—Ä–∞–Ω—è–µ–º –µ–µ
        if ranked_coins and current_coin == ranked_coins[0][0]:
            return current_coin

        # –ò—â–µ–º —Å–ª–µ–¥—É—é—â—É—é –ø–æ–¥—Ö–æ–¥—è—â—É—é –º–æ–Ω–µ—Ç—É
        for coin, score in ranked_coins:
            if coin == current_coin:
                continue

            perf = self.get_coin_performance(coin)
            if perf["status"] not in ["poor", "unknown"]:
                return coin

        # –ï—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–µ–∫—É—â—É—é –º–æ–Ω–µ—Ç—É
        return current_coin

    def _remove_lowest_performer(self):
        """–£–¥–∞–ª—è–µ—Ç –º–æ–Ω–µ—Ç—É —Å —Å–∞–º–æ–π –Ω–∏–∑–∫–æ–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é"""
        ranked = self.get_ranked_coins()
        if not ranked:
            return

        lowest_coin = ranked[-1][0]
        self.logger.info(
            f"–£–¥–∞–ª–µ–Ω–∏–µ —Å–∞–º–æ–π —Å–ª–∞–±–æ–π –º–æ–Ω–µ—Ç—ã {lowest_coin} –¥–ª—è –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏—è –º–µ—Å—Ç–∞"
        )
        self.data["archived_coins"][lowest_coin] = self.data["active_coins"].pop(
            lowest_coin
        )
        self.save_data()

    def generate_report(self) -> str:
        """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –æ—Ç—á–µ—Ç –æ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ —Å–∏—Å—Ç–µ–º—ã"""
        report = [
            "üìä Coin Ranking System Report",
            f"‚Ä¢ –í—Å–µ–≥–æ —Ä–æ—Ç–∞—Ü–∏–π: {self.data['statistics']['total_rotations']}",
            f"‚Ä¢ –ê–∫—Ç–∏–≤–Ω—ã—Ö –º–æ–Ω–µ—Ç: {len(self.data['active_coins'])}",
            f"‚Ä¢ –í –∞—Ä—Ö–∏–≤–µ: {len(self.data['archived_coins'])}",
            f"‚Ä¢ –°–∏—Å—Ç–µ–º–∞ —Å–æ–∑–¥–∞–Ω–∞: {self.data['statistics']['created_at']}",
            f"‚Ä¢ –ü–æ—Å–ª–µ–¥–Ω—è—è —Ä–æ—Ç–∞—Ü–∏—è: {self.data['statistics']['last_rotation'] or 'N/A'}",
            "",
            "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–∏—Å—Ç–µ–º—ã:",
        ]

        for key, value in self.data["settings"].items():
            report.append(f"  ‚Ä¢ {key}: {value}")

        report.append("\nüèÜ –¢–æ–ø-5 –º–æ–Ω–µ—Ç:")
        ranked = self.get_ranked_coins()[:5]

        for i, (coin, score) in enumerate(ranked, 1):
            perf = self.get_coin_performance(coin)
            report.append(
                f"{i}. {coin}: "
                f"score={score:.2f}, "
                f"status={perf['status']}, "
                f"priority={perf['priority']:.2f}, "
                f"trades={perf['trades']}, "
                f"success={perf['success_rate']:.1%}"
            )

        return "\n".join(report)


===== ./services/model_trainer.py =====
# services/model_trainer.py
import threading
import sys
import os
import time
from app.utils.log_helper import log_maker
import traceback
import logging
import json

# –ò–º–ø–æ—Ä—Ç —Ñ—É–Ω–∫—Ü–∏–∏ –æ–±—É—á–µ–Ω–∏—è –º–æ–¥–µ–ª–∏
try:
    from app.strategies.neural_network.trainer import main as train_model
except ImportError:
    log_maker("‚ùå –û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞ —Ñ—É–Ω–∫—Ü–∏–∏ –æ–±—É—á–µ–Ω–∏—è –º–æ–¥–µ–ª–∏. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—É—Ç—å –∫ –º–æ–¥—É–ª—é.")
    train_model = None


class ModelTrainer:
    def __init__(self, coin_list, interval="5", epochs=100, max_concurrent=1):
        self.coin_list = coin_list
        self.interval = interval  # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–∏–π –∏–Ω—Ç–µ—Ä–≤–∞–ª
        self.epochs = epochs
        self.max_concurrent = max_concurrent
        self.training_queue = []
        self.current_training = 0
        self.thread = threading.Thread(target=self._training_loop, daemon=True)
        self.thread.start()
        self.logger = logging.getLogger("model_trainer")
        self.logger.setLevel(logging.INFO)
        log_maker(
            f"üéì –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω —Ç—Ä–µ–Ω–µ—Ä –º–æ–¥–µ–ª–µ–π. –ò–Ω—Ç–µ—Ä–≤–∞–ª: {interval} –º–∏–Ω. –ú–∞–∫—Å. –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–±—É—á–µ–Ω–∏–π: {max_concurrent}"
        )

        # –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è –º–æ–¥–µ–ª–µ–π
        os.makedirs("models", exist_ok=True)

    def add_to_queue(self, coin, force_retrain=False):
        """–î–æ–±–∞–≤–ª—è–µ—Ç –º–æ–Ω–µ—Ç—É –≤ –æ—á–µ—Ä–µ–¥—å –Ω–∞ –æ–±—É—á–µ–Ω–∏–µ"""
        model_path = f"models/{coin}_neural_model"
        model_file = f"{model_path}.keras"
        error_path = f"{model_path}.error"
        config_path = f"{model_path}.config"

        if os.path.exists(model_file) and not force_retrain:
            return False

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π –º–æ–¥–µ–ª–∏
        existing_interval = self._get_model_interval(config_path)
        interval_mismatch = (
            existing_interval != self.interval if existing_interval else False
        )

        # –ü—Ä–∏—á–∏–Ω—ã –¥–ª—è –ø–µ—Ä–µ–æ–±—É—á–µ–Ω–∏—è
        reasons = []
        if force_retrain:
            reasons.append("–ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –ø–µ—Ä–µ–æ–±—É—á–µ–Ω–∏–µ")
        if interval_mismatch:
            reasons.append(
                f"–Ω–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ –∏–Ω—Ç–µ—Ä–≤–∞–ª–∞ ({existing_interval} ‚â† {self.interval})"
            )
        if not os.path.exists(model_file):
            reasons.append("–º–æ–¥–µ–ª—å –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç")
        if os.path.exists(error_path):
            reasons.append("–ø—Ä–µ–¥—ã–¥—É—â–∞—è –æ—à–∏–±–∫–∞ –æ–±—É—á–µ–Ω–∏—è")

        if reasons:
            reason_str = ", ".join(reasons)
            self.logger.info(f"üß† –¢—Ä–µ–±—É–µ—Ç—Å—è –æ–±—É—á–µ–Ω–∏–µ {coin}: {reason_str}")

            # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ —Ñ–∞–π–ª—ã –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
            if os.path.exists(model_file):
                try:
                    os.remove(model_file)
                    os.remove(f"{model_path}_scaler.npz")
                    self.logger.info(f"üßπ –£–¥–∞–ª–µ–Ω—ã —Å—Ç–∞—Ä—ã–µ —Ñ–∞–π–ª—ã –º–æ–¥–µ–ª–∏ –¥–ª—è {coin}")
                except Exception as e:
                    self.logger.info(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è —Å—Ç–∞—Ä—ã—Ö —Ñ–∞–π–ª–æ–≤: {e}")

            # –î–æ–±–∞–≤–ª—è–µ–º –≤ –æ—á–µ—Ä–µ–¥—å, –µ—Å–ª–∏ –µ—â–µ –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω–∞
            if coin not in self.training_queue:
                # –ù–æ–≤—ã–µ –º–æ–Ω–µ—Ç—ã (–±–µ–∑ –º–æ–¥–µ–ª–∏) –¥–æ–±–∞–≤–ª—è–µ–º –≤ –Ω–∞—á–∞–ª–æ –æ—á–µ—Ä–µ–¥–∏
                if not os.path.exists(model_file) and not os.path.exists(error_path):
                    self.training_queue.insert(0, coin)
                    self.logger.info(
                        f"üöÄ –ú–æ–Ω–µ—Ç–∞ {coin} (–Ω–æ–≤–∞—è) –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ –Ω–∞—á–∞–ª–æ –æ—á–µ—Ä–µ–¥–∏ –æ–±—É—á–µ–Ω–∏—è"
                    )
                else:
                    self.training_queue.append(coin)
                    self.logger.info(
                        f"üß† –ú–æ–Ω–µ—Ç–∞ {coin} –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ –æ—á–µ—Ä–µ–¥—å –Ω–∞ –æ–±—É—á–µ–Ω–∏–µ"
                    )

            else:
                self.logger.info(f"üß† –ú–æ–Ω–µ—Ç–∞ {coin} —É–∂–µ –≤ –æ—á–µ—Ä–µ–¥–∏ –Ω–∞ –æ–±—É—á–µ–Ω–∏–µ")
            return True
        else:
            self.logger.info(
                f"üß† –ú–æ–¥–µ–ª—å –¥–ª—è {coin} –∞–∫—Ç—É–∞–ª—å–Ω–∞ (–∏–Ω—Ç–µ—Ä–≤–∞–ª: {self.interval} –º–∏–Ω)"
            )
            return False

    def _get_model_interval(self, config_path):
        """–ü–æ–ª—É—á–∞–µ—Ç –∏–Ω—Ç–µ—Ä–≤–∞–ª –∏–∑ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –º–æ–¥–µ–ª–∏"""
        if os.path.exists(config_path):
            try:
                with open(config_path, "r") as f:
                    config = json.load(f)
                    return config.get("interval")
            except:
                return None
        return None

    def _save_model_config(self, config_path, interval):
        """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –º–æ–¥–µ–ª–∏"""
        try:
            with open(config_path, "w") as f:
                json.dump({"interval": interval}, f)
        except Exception as e:
            log_maker(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –º–æ–¥–µ–ª–∏: {e}")

    def start_periodic_retraining(self, interval_hours=24):
        """–ó–∞–ø—É—Å–∫–∞–µ—Ç –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–µ –ø–µ—Ä–µ–æ–±—É—á–µ–Ω–∏–µ –∫–∞–∂–¥—ã–µ N —á–∞—Å–æ–≤"""

        def retrain_loop():
            while True:
                time.sleep(interval_hours * 3600)
                self.logger.info(
                    f"üîÑ –ó–∞–ø—É—Å–∫ –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–≥–æ –ø–µ—Ä–µ–æ–±—É—á–µ–Ω–∏—è –º–æ–¥–µ–ª–µ–π (–∏–Ω—Ç–µ—Ä–≤–∞–ª: {self.interval} –º–∏–Ω)"
                )
                for coin in self.coin_list:
                    self.add_to_queue(coin, force_retrain=True)

        threading.Thread(target=retrain_loop, daemon=True).start()

    def _training_loop(self):
        """–û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—á–µ—Ä–µ–¥–∏ –æ–±—É—á–µ–Ω–∏—è"""
        while True:
            try:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∑–∞–ø—É—Å–∫–∞ –Ω–æ–≤–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è
                if self.training_queue and self.current_training < self.max_concurrent:

                    coin = self.training_queue.pop(0)
                    self.current_training += 1

                    # –ó–∞–ø—É—Å–∫–∞–µ–º –æ–±—É—á–µ–Ω–∏–µ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
                    threading.Thread(
                        target=self._train_coin_model, args=(coin,), daemon=True
                    ).start()

                time.sleep(10)  # –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—á–µ—Ä–µ–¥—å –∫–∞–∂–¥—ã–µ 10 —Å–µ–∫—É–Ω–¥
            except Exception as e:
                log_maker(f"üî• –û—à–∏–±–∫–∞ –≤ —Ü–∏–∫–ª–µ –æ–±—É—á–µ–Ω–∏—è: {str(e)}")
                traceback.print_exc()
                time.sleep(30)

    def _train_coin_model(self, coin):
        """–û–±—É—á–∞–µ—Ç –º–æ–¥–µ–ª—å –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –º–æ–Ω–µ—Ç—ã"""
        symbol = f"{coin}USDT"
        model_path = f"models/{coin}_neural_model"
        config_path = f"{model_path}.config"

        try:
            log_maker(f"üß† –ù–∞—á–∏–Ω–∞—é –æ–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏ –¥–ª—è {symbol} ({self.interval} –º–∏–Ω)")

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ –æ–±—É—á–µ–Ω–∏—è
            if train_model is None:
                raise ImportError("–§—É–Ω–∫—Ü–∏—è –æ–±—É—á–µ–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")

            # –°–æ–∑–¥–∞–µ–º –∞—Ä–≥—É–º–µ–Ω—Ç—ã –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è
            original_argv = sys.argv.copy()
            sys.argv = [
                "trainer.py",
                f"--symbol={symbol}",
                f"--interval={self.interval}",  # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—É—â–∏–π –∏–Ω—Ç–µ—Ä–≤–∞–ª
                f"--epochs={str(self.epochs)}",
                f"--model_path={model_path}",
            ]

            log_maker(f"üîß –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –æ–±—É—á–µ–Ω–∏—è: {' '.join(sys.argv[1:])}")

            # –í—ã–∑—ã–≤–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é –æ–±—É—á–µ–Ω–∏—è
            train_model()

            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é –º–æ–¥–µ–ª–∏
            self._save_model_config(config_path, self.interval)

            log_maker(
                f"‚úÖ –ú–æ–¥–µ–ª—å –¥–ª—è {symbol} ({self.interval} –º–∏–Ω) —É—Å–ø–µ—à–Ω–æ –æ–±—É—á–µ–Ω–∞ –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞"
            )

        except Exception as e:
            error_msg = f"‚ùå –û—à–∏–±–∫–∞ –æ–±—É—á–µ–Ω–∏—è –º–æ–¥–µ–ª–∏ –¥–ª—è {symbol} ({self.interval} –º–∏–Ω): {str(e)}"
            log_maker(error_msg)
            traceback.print_exc()

            # –°–æ–∑–¥–∞–µ–º —Ñ–∞–π–ª –æ—à–∏–±–∫–∏
            try:
                with open(f"{model_path}.error", "w") as f:
                    f.write(error_msg)
            except:
                pass

        finally:
            # –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –∞—Ä–≥—É–º–µ–Ω—Ç—ã
            sys.argv = original_argv
            self.current_training -= 1

    def force_retrain_all(self):
        """–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –ø–µ—Ä–µ–æ–±—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö –º–æ–¥–µ–ª–µ–π"""
        log_maker("üîÑ –ó–∞–ø—É—Å–∫ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–≥–æ –ø–µ—Ä–µ–æ–±—É—á–µ–Ω–∏—è –≤—Å–µ—Ö –º–æ–¥–µ–ª–µ–π")
        for coin in self.coin_list:
            self.add_to_queue(coin, force_retrain=True)


===== ./services/coin_selector.py =====
import numpy as np
from app.services.bybit_service import BybitService
from app.utils.log_helper import log_maker
from typing import Dict, List, Optional, Tuple
import math
import concurrent.futures
import time

class CoinSelector:
    def __init__(self, coin_list: List[str]):
        self.coin_list = coin_list
        self.bybit = BybitService()
        self.cache: Dict[str, dict] = {}
        self.timeout = 25  # –£–≤–µ–ª–∏—á–∏–º —Ç–∞–π–º–∞—É—Ç –¥–æ 25 —Å–µ–∫—É–Ω–¥
        self.max_workers = 4  # –û–ø—Ç–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Ç–æ–∫–æ–≤
        self.last_update = 0
        self.update_interval = 3600  # –û–±–Ω–æ–≤–ª—è—Ç—å –¥–∞–Ω–Ω—ã–µ —Ä–∞–∑ –≤ —á–∞—Å
        
    def calculate_volatility(self, closes: List[float]) -> float:
        """–†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å –∫–∞–∫ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –ø—Ä–æ—Ü–µ–Ω—Ç–Ω—ã—Ö –∏–∑–º–µ–Ω–µ–Ω–∏–π"""
        if len(closes) < 2:
            return 0.0
            
        # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –ø—Ä–æ—Ü–µ–Ω—Ç–Ω—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è
        returns = []
        for i in range(1, len(closes)):
            if closes[i-1] != 0:  # –ó–∞—â–∏—Ç–∞ –æ—Ç –¥–µ–ª–µ–Ω–∏—è –Ω–∞ –Ω–æ–ª—å
                ret = (closes[i] - closes[i-1]) / closes[i-1]
                returns.append(ret)
        
        if len(returns) < 2:
            return 0.0
            
        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ –≤ –ø—Ä–æ—Ü–µ–Ω—Ç–∞—Ö
        return np.std(returns) * 100
        
    def sigmoid_normalize(self, value: float, midpoint: float, steepness: float = 10) -> float:
        """–ù–æ—Ä–º–∞–ª–∏–∑—É–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ —á–µ—Ä–µ–∑ —Å–∏–≥–º–æ–∏–¥—É —Å –∑–∞—â–∏—Ç–æ–π –æ—Ç –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—è"""
        try:
            x = steepness * (value - midpoint)
            # –ó–∞—â–∏—Ç–∞ –æ—Ç —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π
            if x > 100:
                return 1.0
            elif x < -100:
                return 0.0
            return 1 / (1 + math.exp(-x))
        except:
            return 0.5  # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –Ω–µ–π—Ç—Ä–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø—Ä–∏ –æ—à–∏–±–∫–µ
        
    def calculate_metrics(self, symbol: str) -> Optional[dict]:
        """–†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç –º–µ—Ç—Ä–∏–∫–∏ –¥–ª—è –æ–¥–Ω–æ–π –º–æ–Ω–µ—Ç—ã —Å –ø–æ–≤—Ç–æ—Ä–Ω—ã–º–∏ –ø–æ–ø—ã—Ç–∫–∞–º–∏"""
        for attempt in range(3):  # 3 –ø–æ–ø—ã—Ç–∫–∏
            try:
                # –ü–æ–ª—É—á–∞–µ–º —Å–≤–µ—á–∏ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 4 —á–∞—Å–∞ (15-–º–∏–Ω—É—Ç–Ω—ã–µ)
                candles = self.bybit.get_candles(symbol, interval="15", limit=16)
                
                if not candles or len(candles) < 15:
                    if attempt == 2:  # –ü–æ—Å–ª–µ–¥–Ω—è—è –ø–æ–ø—ã—Ç–∫–∞
                        log_maker(f"‚ö†Ô∏è –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {symbol}")
                        return None
                    time.sleep(2)  # –ü–∞—É–∑–∞ –ø–µ—Ä–µ–¥ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–æ–π
                    continue
                    
                closes = [c['close'] for c in candles]
                volumes = [c['volume'] for c in candles]
                highs = [c['high'] for c in candles]
                lows = [c['low'] for c in candles]
                
                # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –ø–æ–∫–∞–∑–∞—Ç–µ–ª–∏
                volatility = self.calculate_volatility(closes)
                
                # –¢—Ä–µ–Ω–¥ (–Ω–∞–∫–ª–æ–Ω –ª–∏–Ω–∏–∏ —Ä–µ–≥—Ä–µ—Å—Å–∏–∏)
                x = np.arange(len(closes))
                slope = np.polyfit(x, closes, 1)[0]
                mean_price = np.mean(closes)
                trend_strength = (slope / mean_price) * 100 if mean_price != 0 else 0
                
                # –û—Ç–Ω–æ—à–µ–Ω–∏–µ –æ–±—ä–µ–º–∞ –∫ —Å—Ä–µ–¥–Ω–µ–º—É
                if len(volumes) >= 5:
                    avg_volume = np.mean(volumes[-5:])
                    volume_ratio = volumes[-1] / avg_volume if avg_volume != 0 else 1.0
                else:
                    volume_ratio = 1.0
                
                # ATR (Average True Range)
                atr = self._calculate_atr(highs, lows, closes)
                
                # –°–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ —Ä–∏—Å–∫/–ø—Ä–∏–±—ã–ª—å (–Ω–∞ –æ—Å–Ω–æ–≤–µ ATR)
                risk_reward = (atr / closes[-1]) * 100 if closes[-1] != 0 else 0
                
                return {
                    'volatility': volatility,
                    'trend_strength': trend_strength,
                    'volume_ratio': volume_ratio,
                    'risk_reward': risk_reward,
                    'price': closes[-1],
                    'atr': atr
                }
                
            except Exception as e:
                if attempt == 2:  # –ü–æ—Å–ª–µ–¥–Ω—è—è –ø–æ–ø—ã—Ç–∫–∞
                    log_maker(f"üî• –û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ –º–µ—Ç—Ä–∏–∫ –¥–ª—è {symbol}: {str(e)}")
                    return None
                time.sleep(1)  # –ü–∞—É–∑–∞ –ø–µ—Ä–µ–¥ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–æ–π
    
    def _calculate_atr(self, highs: List[float], lows: List[float], closes: List[float], period: int = 14) -> float:
        """–†–∞—Å—á–µ—Ç Average True Range"""
        if len(highs) < period or len(closes) < 2:
            return 0.0
        
        tr_values = []
        for i in range(1, len(highs)):
            tr1 = highs[i] - lows[i]
            tr2 = abs(highs[i] - closes[i-1])
            tr3 = abs(lows[i] - closes[i-1])
            tr = max(tr1, tr2, tr3)
            tr_values.append(tr)
        
        return np.mean(tr_values[-period:]) if tr_values else 0.0
    
    def evaluate_coins(self) -> List[Tuple[str, float]]:
        """–û—Ü–µ–Ω–∏–≤–∞–µ—Ç –≤—Å–µ –º–æ–Ω–µ—Ç—ã —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤"""
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫—ç—à, –µ—Å–ª–∏ –¥–∞–Ω–Ω—ã–µ –Ω–µ —É—Å—Ç–∞—Ä–µ–ª–∏
        current_time = time.time()
        if current_time - self.last_update < self.update_interval:
            return self._get_cached_scores()
        
        scores = []
        self.cache = {}  # –û—á–∏—â–∞–µ–º –∫—ç—à –ø–µ—Ä–µ–¥ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º
        
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º ThreadPoolExecutor –¥–ª—è –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
        with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            future_to_coin = {
                executor.submit(self._evaluate_coin, coin): coin
                for coin in self.coin_list
            }
            
            for future in concurrent.futures.as_completed(future_to_coin, timeout=self.timeout):
                coin = future_to_coin[future]
                try:
                    # –î–æ–±–∞–≤–ª—è–µ–º —Ç–∞–π–º–∞—É—Ç –¥–ª—è –∫–∞–∂–¥–æ–≥–æ future
                    result = future.result(timeout=15)
                    if result:
                        scores.append(result)
                except Exception as e:
                    # –õ–æ–≥–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ —Å–µ—Ä—å–µ–∑–Ω—ã–µ –æ—à–∏–±–∫–∏
                    if "Not supported symbols" not in str(e):
                        log_maker(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ—Ü–µ–Ω–∫–∏ {coin}: {str(e)}")
                    else:
                        # –î–ª—è "Not supported symbols" –ø—Ä–æ—Å—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º 0 –æ—Ü–µ–Ω–∫—É
                        scores.append((coin, 0.0))
        
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —É–±—ã–≤–∞–Ω–∏—é –æ—Ü–µ–Ω–∫–∏
        scores.sort(key=lambda x: x[1], reverse=True)
        self.last_update = current_time
        return scores
    
    def _get_cached_scores(self) -> List[Tuple[str, float]]:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ—Ü–µ–Ω–∫–∏ –∏–∑ –∫—ç—à–∞"""
        scores = []
        for coin in self.coin_list:
            if coin in self.cache:
                scores.append((coin, self.cache[coin]['score']))
        scores.sort(key=lambda x: x[1], reverse=True)
        return scores
    
    def _evaluate_coin(self, coin: str) -> Optional[Tuple[str, float]]:
        """–í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –º–µ—Ç–æ–¥ –¥–ª—è –æ—Ü–µ–Ω–∫–∏ –æ–¥–Ω–æ–π –º–æ–Ω–µ—Ç—ã"""
        symbol = f"{coin}USDT"
        metrics = self.calculate_metrics(symbol)
        
        if not metrics:
            return None
            
        # –í–µ—Å–æ–≤—ã–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã
        weights = {
            'volatility': 0.4,
            'trend_strength': 0.3,
            'volume_ratio': 0.2,
            'risk_reward': 0.1
        }
        
        # –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –∑–Ω–∞—á–µ–Ω–∏–π —á–µ—Ä–µ–∑ —Å–∏–≥–º–æ–∏–¥—É
        normalized = {
            'volatility': self.sigmoid_normalize(metrics['volatility'], 1.0),
            'trend_strength': self.sigmoid_normalize(metrics['trend_strength'], 0.5),
            'volume_ratio': min(max(metrics['volume_ratio'], 0.5), 3.0) / 3.0,
            'risk_reward': self.sigmoid_normalize(metrics['risk_reward'], 1.0)
        }
        
        # –†–∞—Å—Å—á–µ—Ç –∏—Ç–æ–≥–æ–≤–æ–π –æ—Ü–µ–Ω–∫–∏
        score = sum(normalized[k] * weights[k] for k in weights)
        
        # –ö—ç—à–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
        self.cache[coin] = {
            'metrics': metrics,
            'score': score,
            'normalized': normalized,
            'timestamp': time.time()
        }
        
        return (coin, score)
    
    def get_best_coin(self) -> Optional[str]:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ª—É—á—à—É—é –º–æ–Ω–µ—Ç—É –¥–ª—è —Ç–æ—Ä–≥–æ–≤–ª–∏"""
        scores = self.evaluate_coins()
        if not scores:
            return None
        return scores[0][0]
    
    def get_coin_report(self, coin: str) -> Optional[dict]:
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –¥–µ—Ç–∞–ª—å–Ω—ã–π –æ—Ç—á–µ—Ç –ø–æ –º–æ–Ω–µ—Ç–µ"""
        return self.cache.get(coin)

===== ./services/__init__.py =====
from .coin_ranker import CoinRanker
from .coin_rotator import CoinRotator
from .coin_selector import CoinSelector
from .model_trainer import ModelTrainer
from .bybit_service import BybitService
from .bot_runner import TradingBot



__all__ = [
    'CoinRanker', 
    'CoinRotator', 
    'CoinSelector', 
    'ModelTrainer', 
    'BybitService', 
    'TradingBot'
]

===== ./services/trading_system.py =====
import os
import json
import time
from app.services.coin_ranker import CoinRanker
from app.services.model_trainer import ModelTrainer
from app.services.bybit_service import BybitService
from app.strategies.ma_crossover import MovingAverageStrategy
from app.strategies.neural_strategy import NeuralStrategy
from app.utils.log_helper import log_maker
from app.services.coin_rotator import CoinRotator

class TradingSystem:
    def __init__(self, coin_list):
        self.coin_list = coin_list
        self.state = self.load_state()
        self.bybit = BybitService()
        self.ranker = CoinRanker()
        self.model_trainer = ModelTrainer(coin_list)
        self.rotator = CoinRotator(coin_list, trading_system=self)
        self.position_open_time = self.state.get("position_open_time", 0)
        self.position_coin = self.state.get("position_coin", "")
        self.max_hold_hours = 24
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã
        self.ranker.add_new_coins(coin_list)
        self.current_coin = self.state.get("current_coin", coin_list[0])
        self.current_symbol = f"{self.current_coin}USDT"
        self._init_strategy()  # –í—ã–∑—ã–≤–∞–µ–º –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
        
        # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–µ–π –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ
        self.train_missing_models()
        self.model_trainer.start_periodic_retraining()
        
        log_maker(f"‚öôÔ∏è –¢–æ—Ä–≥–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞. –¢–µ–∫—É—â–∞—è –º–æ–Ω–µ—Ç–∞: {self.current_coin}")
    
    def train_missing_models(self):
        """–û–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–µ–π –¥–ª—è –º–æ–Ω–µ—Ç, —É –∫–æ—Ç–æ—Ä—ã—Ö –æ–Ω–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç"""
        for coin in self.coin_list:
            model_path = f"models/{coin}_neural_model.keras"
            if not os.path.exists(model_path):
                log_maker(f"üß† –ú–æ–¥–µ–ª—å –¥–ª—è {coin} –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç. –î–æ–±–∞–≤–ª—è—é –≤ –æ—á–µ—Ä–µ–¥—å –æ–±—É—á–µ–Ω–∏—è.")
                self.model_trainer.add_to_queue(coin, force_retrain=True)
    
    def load_state(self):
        try:
            with open("bot_state.json", "r") as f:
                return json.load(f)
        except:
            return {"current_coin": self.coin_list[0]}

    def save_state(self):
        """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã"""
        self.state = {
            "current_coin": self.current_coin,
            "position_open_time": self.position_open_time,
            "position_coin": self.position_coin
        }
        with open("bot_state.json", "w") as f:
            json.dump(self.state, f, indent=2)

    def _init_strategy(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç —Å—Ç—Ä–∞—Ç–µ–≥–∏—é —Å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –≤—ã–±–æ—Ä–æ–º —Ç–∏–ø–∞"""
        # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–∏–º–≤–æ–ª –∏ –ø—É—Ç—å –∫ –º–æ–¥–µ–ª–∏
        symbol = f"{self.current_coin}USDT"
        model_base = f"models/{self.current_coin}_neural_model"
        model_file = f"{model_base}.keras"
        
        try:
            # –ü—ã—Ç–∞–µ–º—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–≤—É—é —Å—Ç—Ä–∞—Ç–µ–≥–∏—é, –µ—Å–ª–∏ –º–æ–¥–µ–ª—å –¥–æ—Å—Ç—É–ø–Ω–∞
            if os.path.exists(model_file):
                self.strategy = NeuralStrategy(
                    symbol, 
                    bybit_service=self.bybit,
                    model_path=model_base,
                    rotator=self.rotator,
                    trading_system=self
                )
                log_maker(f"üß† –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –Ω–µ–π—Ä–æ—Å–µ—Ç–µ–≤–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è –¥–ª—è {symbol}")
            else:
                # Fallback –Ω–∞ MA —Å—Ç—Ä–∞—Ç–µ–≥–∏—é
                log_maker(f"üîÑ –ú–æ–¥–µ–ª—å –¥–ª—è {symbol} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ò—Å–ø–æ–ª—å–∑—É—é MA —Å—Ç—Ä–∞—Ç–µ–≥–∏—é")
                self.strategy = MovingAverageStrategy(
                    symbol, 
                    "3", 
                    rotator=self.rotator,
                    trading_system=self
                )
                
                # –ó–∞–ø—É—Å–∫–∞–µ–º –æ–±—É—á–µ–Ω–∏–µ –º–æ–¥–µ–ª–∏ –≤ —Ñ–æ–Ω–µ
                self.model_trainer.add_to_queue(self.current_coin, force_retrain=True)
        except Exception as e:
            # –î–≤–æ–π–Ω–æ–π fallback –Ω–∞ —Å–ª—É—á–∞–π –æ—à–∏–±–∫–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
            log_maker(f"üî• –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏: {e}. –ò—Å–ø–æ–ª—å–∑—É—é –±–∞–∑–æ–≤—É—é MA.")
            self.strategy = MovingAverageStrategy(
                symbol, 
                "3", 
                rotator=self.rotator,
                trading_system=self
            )
    
    def health_check(self):
        return {
            "current_coin": self.current_coin,
            "position_open": self.position_open_time > 0,
            "position_hours": (time.time() - self.position_open_time) / 3600 if self.position_open_time else 0
        }

    def start(self):
        log_maker("üöÄ –°–∏—Å—Ç–µ–º–∞ —Ç–æ—Ä–≥–æ–≤–ª–∏ –∑–∞–ø—É—â–µ–Ω–∞")

    def stop(self):
        log_maker("üõë –°–∏—Å—Ç–µ–º–∞ —Ç–æ—Ä–≥–æ–≤–ª–∏ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞")

    def switch_coin(self, new_coin: str):
        """–ü–µ—Ä–µ–∫–ª—é—á–∞–µ—Ç —Ç–æ—Ä–≥—É–µ–º—É—é –º–æ–Ω–µ—Ç—É"""
        self.current_coin = new_coin
        self.current_symbol = f"{new_coin}USDT"  # –û–±–Ω–æ–≤–ª—è–µ–º —Å–∏–º–≤–æ–ª
        self.save_state()
        self._init_strategy()

    def check_force_close(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç—å –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–≥–æ –∑–∞–∫—Ä—ã—Ç–∏—è –ø–æ–∑–∏—Ü–∏–∏"""
        if self.position_open_time == 0:
            return False
            
        # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –≤—Ä–µ–º—è —É–¥–µ—Ä–∂–∞–Ω–∏—è –≤ —á–∞—Å–∞—Ö
        hold_hours = (time.time() - self.position_open_time) / 3600
        return hold_hours >= self.max_hold_hours

===== ./utils/log_helper.py =====
from app.notifier import send_telegram_message


def log_maker(message: str, buy_sell: bool = False):
    print(message)
    send_telegram_message(message, buy_sell=buy_sell)

def log_error(message: str):
    """–õ–æ–≥–∏—Ä—É–µ—Ç –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –æ—à–∏–±–∫–∏"""
    error_message = f"üî• [CRITICAL] {message}"
    print(error_message)
    send_telegram_message(error_message, buy_sell=True)

===== ./utils/place_order.py =====
import json
import os
from datetime import datetime, timezone
from app.utils.log_helper import log_maker
from pybit.unified_trading import HTTP


LOG_PATH = "logs/order_failures.json"


def log_order_failure(context: dict):
    os.makedirs(os.path.dirname(LOG_PATH), exist_ok=True)
    log_entry = {"timestamp": datetime.now(timezone.utc).isoformat(), **context}
    with open(LOG_PATH, "a", encoding="utf-8") as f:
        f.write(json.dumps(log_entry, ensure_ascii=False) + "\n")


def safe_place_order(
    client: HTTP,
    symbol: str,
    side: str,
    qty: str,
    order_type: str = "Market",
    category: str = "spot",
) -> dict | None:
    payload = {
        "category": category,
        "symbol": symbol,
        "side": side.upper(),
        "order_type": order_type,
        "qty": qty,
    }

    # –ü–æ–ø—ã—Ç–∫–∞ ‚Ññ1 ‚Äî —Å accountType="UNIFIED"
    try:
        log_maker("üõ†Ô∏è [TRY] –ü—Ä–æ–±—É–µ–º –æ—Ä–¥–µ—Ä —Å accountType='UNIFIED'")
        response = client.place_order(**payload, accountType="UNIFIED")
        if response["retCode"] == 0:
            log_maker("‚úÖ [SUCCESS] –û—Ä–¥–µ—Ä —É—Å–ø–µ—à–Ω–æ —Ä–∞–∑–º–µ—â—ë–Ω —Å accountType='UNIFIED'")
            return response
        log_maker(
            f"‚ùå [FAILURE] –û—à–∏–±–∫–∞ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –æ—Ä–¥–µ—Ä–∞: retCode {response['retCode']} ‚Äî {response['retMsg']}"
        )
    except Exception as e:
        log_maker(f"üö® [ERROR] –ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ –ø–æ–ø—ã—Ç–∫–µ –æ—Ä–¥–µ—Ä–∞ —Å accountType='UNIFIED': {e}")

        log_order_failure(
            {
                "symbol": symbol,
                "side": side,
                "qty": qty,
                "category": category,
                "accountType": "UNIFIED",
                "error": str(e),
            }
        )

    # –ü–æ–ø—ã—Ç–∫–∞ ‚Ññ2 ‚Äî –±–µ–∑ accountType
    try:
        log_maker("üõ†Ô∏è [TRY] –ü—Ä–æ–±—É–µ–º –æ—Ä–¥–µ—Ä *–±–µ–∑* accountType")
        response = client.place_order(**payload)
        if response["retCode"] == 0:
            log_maker("‚úÖ [SUCCESS] –û—Ä–¥–µ—Ä —É—Å–ø–µ—à–Ω–æ —Ä–∞–∑–º–µ—â—ë–Ω *–±–µ–∑* accountType")
            return response
        log_maker(
            f"‚ùå [FAILURE] –û—à–∏–±–∫–∞ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –æ—Ä–¥–µ—Ä–∞: retCode {response['retCode']} ‚Äî {response['retMsg']}"
        )
    except Exception as e:
        log_maker(f"üö® [ERROR] –ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ —Ä–∞–∑–º–µ—â–µ–Ω–∏–∏ *–±–µ–∑* accountType: {e}")
        log_order_failure(
            {
                "symbol": symbol,
                "side": side,
                "qty": qty,
                "category": category,
                "accountType": "UNSPECIFIED",
                "error": str(e),
            }
        )

    return None


===== ./utils/coin_loader.py =====
# ./utils/coin_loader.py
def load_coin_list(file_path: str) -> list:
    try:
        with open(file_path, 'r') as f:
            return [line.strip().upper() for line in f if line.strip()]
    except:
        return ["SOL", "BTC", "ETH"]  # Default coins

===== ./utils/get_history.py =====
import requests
import pandas as pd
import json

def fetch_bybit_ohlcv_15m(symbol="SOLUSDT", category="spot"):
    url = "https://api.bybit.com/v5/market/kline"
    params = {
        "category": category,
        "symbol": symbol,
        "interval": "15m",
        "limit": 96
    }

    response = requests.get(url, params=params)
    data = response.json()

    if data["retCode"] != 0:
        raise Exception(f"API error: {data['retMsg']}")

    raw = data["result"]["list"]

    if not raw:
        print("‚ùå No data returned. Check symbol and category.")
        return pd.DataFrame()

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ —Ñ–∞–π–ª (–≤ –ø–æ—Ä—è–¥–∫–µ –ø–æ —É–±—ã–≤–∞–Ω–∏—é –≤—Ä–µ–º–µ–Ω–∏)
    with open(f"ohlcv_{symbol}.json", "w") as f:
        json.dump(raw, f, indent=2)

    # –ü–∞—Ä—Å–∏–Ω–≥ –∏ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ (–ø–æ –≤–æ–∑—Ä–∞—Å—Ç–∞–Ω–∏—é)
    df = pd.DataFrame(raw, columns=[
        "timestamp", "open", "high", "low", "close", "volume", "_1", "_2"
    ])

    df = df.astype({
        "timestamp": "int64",
        "open": "float",
        "high": "float",
        "low": "float",
        "close": "float",
        "volume": "float"
    })

    df["timestamp"] = pd.to_datetime(df["timestamp"], unit="ms")
    df = df[["timestamp", "open", "high", "low", "close", "volume"]]
    df = df.sort_values("timestamp").reset_index(drop=True)

    return df

# üß™ –ü—Ä–∏–º–µ—Ä –∑–∞–ø—É—Å–∫–∞
if __name__ == "__main__":
    df = fetch_bybit_ohlcv_15m("SOLUSDT", "spot")
    if not df.empty:
        print(df.tail())


===== ./utils/trading_utils.py =====
from decimal import ROUND_DOWN, Decimal

def round_qty(qty: float, precision: int) -> float:
    quantize_str = "1" if precision == 0 else "1." + "0" * precision
    return float(Decimal(str(qty)).quantize(Decimal(quantize_str), rounding=ROUND_DOWN))

===== ./utils/get_profit.py =====
import time
import hmac
import hashlib
import requests
from datetime import datetime, timedelta
import urllib.parse

class ProfitCalculator:
    def __init__(self, api_key, api_secret):
        self.api_key = api_key
        self.api_secret = api_secret
        self.base_url = "https://api.bybit.com"
        self.recv_window = "5000"

    def _generate_signature(self, params):
        timestamp = str(int(time.time() * 1000))
        encoded_params = urllib.parse.urlencode(params, doseq=True)
        sign_str = timestamp + self.api_key + self.recv_window + encoded_params
        signature = hmac.new(
            self.api_secret.encode('utf-8'),
            sign_str.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()
        return timestamp, signature

    def get_balance_history(self, days=1, coin="USDT", account_type="UNIFIED", limit=50):
        end_time = int(datetime.now().timestamp() * 1000)
        start_time = int((datetime.now() - timedelta(days=days)).timestamp() * 1000)
        
        params = {
            "accountType": account_type,
            "startTime": start_time,
            "endTime": end_time,
            "limit": limit,
            "coin": coin
        }
        
        timestamp, signature = self._generate_signature(params)
        
        headers = {
            "X-BAPI-API-KEY": self.api_key,
            "X-BAPI-TIMESTAMP": timestamp,
            "X-BAPI-SIGN": signature,
            "X-BAPI-RECV-WINDOW": self.recv_window,
        }
        
        endpoint = "/v5/account/transaction-log"
        url = f"{self.base_url}{endpoint}"
        response = requests.get(url, params=params, headers=headers)
        
        return response.json()

    def calculate_profit(self, history):
        if not history or history.get("retCode") != 0:
            return 0.0, 0.0

        transactions = history.get("result", {}).get("list", [])
        today = datetime.now().date()
        month_start = today.replace(day=1)
        
        profit_today = 0.0
        profit_month = 0.0
        
        for tx in transactions:
            if tx.get("currency") == "USDT" and tx.get("type") == "TRADE":
                tx_time = int(tx.get("transactionTime", 0)) / 1000
                if tx_time == 0:
                    continue
                    
                tx_date = datetime.fromtimestamp(tx_time).date()
                change = float(tx.get("change", 0))
                
                # –£—á–∏—Ç—ã–≤–∞–µ–º –∫–æ–º–∏—Å—Å–∏—é
                if tx.get("fee") and tx["fee"] != "0":
                    fee = float(tx["fee"])
                    change -= fee
                    
                profit_month += change
                if tx_date == today:
                    profit_today += change
                    
        return profit_today, profit_month

===== ./utils/symbol_selector.py =====
# app/services/symbol_selector.py
import numpy as np
from app.services.bybit_service import BybitService
from app.strategies.ma_crossover import MovingAverageStrategy
from app.utils.log_helper import log_maker

class SymbolSelector:
    def __init__(self, symbols: list, volatility_window: int = 24):
        self.symbols = symbols
        self.window = volatility_window
        self.bybit = BybitService()
        self.strategies = {s: MovingAverageStrategy(s) for s in symbols}
        self.scores = {}  # –î–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Ç–µ–∫—É—â–∏—Ö –±–∞–ª–ª–æ–≤
        
    def calculate_volatility_score(self, symbol: str) -> float:
        """–û—Ü–µ–Ω–∫–∞ –ø—Ä–∏–≤–ª–µ–∫–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –º–æ–Ω–µ—Ç—ã 0-100 –±–∞–ª–ª–æ–≤"""
        candles = self.bybit.get_candles(symbol, "60", limit=self.window)
        if not candles:
            return 0
            
        # 1. –ò—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∞—è –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å
        closes = [c['close'] for c in candles]
        if len(closes) < 2:
            return 0
            
        returns = np.diff(np.log(closes))
        volatility = np.std(returns) * 100 if returns else 0
        
        # 2. –û–±—ä–µ–º—ã
        volumes = [c['volume'] for c in candles[-6:]]
        if not volumes:
            volume_ratio = 1
        else:
            min_vol = min(volumes) if min(volumes) > 0 else 1
            volume_ratio = max(volumes) / min_vol
        
        # 3. –¢–µ–∫—É—â–∏–π —Ç—Ä–µ–Ω–¥ (EMA slope)
        try:
            strategy = self.strategies[symbol]
            strategy.should_trade(candles)  # –æ–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ EMA
            if strategy.prev_medium_ema and strategy.prev_medium_ema > 0:
                slope = (strategy.prev_short_ema - strategy.prev_medium_ema) / strategy.prev_medium_ema
            else:
                slope = 0
        except Exception as e:
            log_maker(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ —Ç—Ä–µ–Ω–¥–∞ –¥–ª—è {symbol}: {e}")
            slope = 0
        
        # –ö–æ–º–ø–æ–∑–∏—Ç–Ω—ã–π –±–∞–ª–ª
        return (volatility * 70) + (volume_ratio * 20) + (abs(slope) * 1000 * 10)

    def select_best_symbol(self, current_symbol: str = None):
        """–í—ã–±–æ—Ä —Å–∏–º–≤–æ–ª–∞ —Å –ø–æ–≤—ã—à–∞—é—â–∏–º –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–º –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ"""
        scores = {}
        for symbol in self.symbols:
            try:
                score = self.calculate_volatility_score(symbol)
                
                # –ü–æ–≤—ã—à–∞–µ–º –±–∞–ª —Ç–µ–∫—É—â–µ–≥–æ —Å–∏–º–≤–æ–ª–∞ –Ω–∞ 10%
                if symbol == current_symbol:
                    score *= 1.1
                    
                scores[symbol] = score
            except Exception as e:
                log_maker(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ—Ü–µ–Ω–∫–∏ {symbol}: {e}")
                scores[symbol] = 0
        
        self.scores = scores  # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –±–æ—Ç–µ
        best_symbol = max(scores, key=scores.get)
        return best_symbol, scores[best_symbol]

===== ./utils/__init__.py =====
from .coin_loader import load_coin_list
from .get_profit import ProfitCalculator
from .log_helper import log_maker
from .place_order import log_order_failure, safe_place_order
from .trading_utils import round_qty
from .get_history import fetch_bybit_ohlcv_15m

__all__ = [
    'load_coin_list',
    'ProfitCalculator',
    'log_maker',
    'log_order_failure',
    'safe_place_order',
    'round_qty',
    'fetch_bybit_ohlcv_15m'
]


===== ./utils/candle_sync.py =====
import time
import math


class CandleSynchronizer:
    def __init__(self, interval_minutes: int = 5):
        self.interval_seconds = interval_minutes * 60

    def get_next_execution_time(self):
        current_time = time.time()
        next_candle = (
            math.ceil(current_time / self.interval_seconds) * self.interval_seconds
        )
        return next_candle

    def time_until_next_execution(self):
        return self.get_next_execution_time() - time.time()

    def sync(self):
        sleep_time = self.time_until_next_execution()
        if sleep_time > 0:
            time.sleep(sleep_time)

    def time_until_next_candle(self):  # <-- –î–æ–±–∞–≤—å—Ç–µ —ç—Ç–æ—Ç –º–µ—Ç–æ–¥
        """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–∫—É–Ω–¥ –¥–æ –Ω–∞—á–∞–ª–∞ —Å–ª–µ–¥—É—é—â–µ–π —Å–≤–µ—á–∏"""
        current_time = time.time()
        next_candle_start = math.ceil(current_time / self.interval_seconds) * self.interval_seconds
        return next_candle_start - current_time
        
    def sync(self):
        """–û–∂–∏–¥–∞–µ—Ç –Ω–∞—á–∞–ª–∞ —Å–ª–µ–¥—É—é—â–µ–π —Å–≤–µ—á–∏"""
        sleep_time = self.time_until_next_candle()
        if sleep_time > 0:
            time.sleep(sleep_time)

===== ../run_bot.py (–¥–æ–±–∞–≤–ª–µ–Ω–æ –æ—Ç–¥–µ–ª—å–Ω–æ) =====
#!/usr/bin/env python3
import logging
import time
import traceback
import os
from app.services.bot_controller import bot_controller
from app.utils import load_coin_list
from app.services.trading_system import TradingSystem
from app.trading.order_executor import OrderExecutor

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("logs/bot_system.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger('main')

def setup_directories():
    """–°–æ–∑–¥–∞–µ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏"""
    os.makedirs("models", exist_ok=True)
    os.makedirs("logs", exist_ok=True)
    os.makedirs("data", exist_ok=True)

def main():
    logger.info("üöÄ –ó–∞–ø—É—Å–∫ —Ç–æ—Ä–≥–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã...")
    setup_directories()
    
    coin_list = load_coin_list("coins_list.txt")
    logger.info(f"üìã –ó–∞–≥—Ä—É–∂–µ–Ω–æ –º–æ–Ω–µ—Ç: {len(coin_list)}")
    
    trading_system = TradingSystem(coin_list=coin_list)
    trading_system.start()
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ –æ—Ç–∫—Ä—ã—Ç–∞—è –ø–æ–∑–∏—Ü–∏—è
    position_coin = trading_system.state.get("position_coin", "")
    if position_coin:
        trading_system.current_coin = position_coin
        trading_system.rotator.set_current_coin(position_coin)
        logger.info(f"‚è™ –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ –æ—Ç–∫—Ä—ã—Ç–æ–π –ø–æ–∑–∏—Ü–∏–∏: {position_coin}")
    
    
    logger.info(f"üèÅ –ù–∞—á–∞–ª—å–Ω–∞—è –º–æ–Ω–µ—Ç–∞: {trading_system.current_coin}")

    bot_controller.start()
    logger.info("ü§ñ –¢–æ—Ä–≥–æ–≤—ã–π –±–æ—Ç –∑–∞–ø—É—â–µ–Ω")
    
    try:
        logger.info("üîÑ –í—Ö–æ–¥ –≤ –æ—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è")
        last_health_check = time.time()
        while True:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –±–æ—Ç–∞
            if bot_controller.status() != "running":
                logger.error("‚ö†Ô∏è –ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω! –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º...")
                bot_controller.start()
            
            # –†–æ—Ç–∞—Ü–∏—è –º–æ–Ω–µ—Ç —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ—Ç –æ—Ç–∫—Ä—ã—Ç–æ–π –ø–æ–∑–∏—Ü–∏–∏
            if not trading_system.position_open_time:
                try:
                    current_coin = trading_system.rotator.rotate_coins()
                    if current_coin != trading_system.current_coin:
                        logger.info(f"üîÑ –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º –º–æ–Ω–µ—Ç—É —Å {trading_system.current_coin} –Ω–∞ {current_coin}")
                        
                        # –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ—á–∏—â–∞–µ–º –æ—Å—Ç–∞—Ç–∫–∏ –ø—Ä–µ–¥—ã–¥—É—â–µ–π –º–æ–Ω–µ—Ç—ã
                        prev_symbol = f"{trading_system.current_coin}USDT"
                        executor = OrderExecutor(prev_symbol)
                        executor.clean_residuals(threshold=0.0001)
                        
                        trading_system.switch_coin(current_coin)
                        bot_controller.switch_coin(current_coin)
                except Exception as e:
                    logger.error(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–æ—Ç–∞—Ü–∏–∏ –º–æ–Ω–µ—Ç: {e}")
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ –ø–æ–∑–∏—Ü–∏–∏
            try:
                if trading_system.position_open_time:
                    symbol = f"{trading_system.current_coin}USDT"
                    logger.info(f"‚è±Ô∏è –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–≥–æ –∑–∞–∫—Ä—ã—Ç–∏—è –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è {symbol}")
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ —Ä–µ–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è
                    positions = trading_system.bybit.get_open_positions()
                    position_exists = any(
                        pos['coin'] == trading_system.current_coin 
                        for pos in positions
                    )
                    
                    if position_exists:
                        executor = OrderExecutor(symbol)
                        if executor.execute_force_close():
                            trading_system.position_open_time = 0
                            logger.info("‚úÖ –ü–æ–∑–∏—Ü–∏—è —É—Å–ø–µ—à–Ω–æ –∑–∞–∫—Ä—ã—Ç–∞")
                        else:
                            logger.warning("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–∫—Ä—ã—Ç—å –ø–æ–∑–∏—Ü–∏—é –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ")
                    else:
                        logger.info("‚è© –ù–µ—Ç –æ—Ç–∫—Ä—ã—Ç–æ–π –ø–æ–∑–∏—Ü–∏–∏, —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥")
                        trading_system.position_open_time = 0
            except Exception as e:
                logger.error(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–≥–æ –∑–∞–∫—Ä—ã—Ç–∏—è: {e}")
            
            # Health check
            if time.time() - last_health_check > 3600:
                logger.info("ü©∫ Health check:")
                logger.info(f"Bot status: {bot_controller.status()}")
                last_health_check = time.time()
            
            # –û–∂–∏–¥–∞–Ω–∏–µ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –ø—Ä–æ–≤–µ—Ä–∫–æ–π
            time.sleep(60)
            
    except KeyboardInterrupt:
        logger.info("üõë –ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª KeyboardInterrupt")
    except Exception as e:
        logger.error(f"üí• –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}")
        logger.error(traceback.format_exc())
    finally:
        logger.info("‚èπÔ∏è –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã —Å–∏—Å—Ç–µ–º—ã...")
        bot_controller.stop()
        trading_system.stop()
        logger.info("‚úÖ –°–∏—Å—Ç–µ–º–∞ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ")

if __name__ == "__main__":
    main()

===== –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞ (tree –∏–∑ ../) =====
../
‚îú‚îÄ‚îÄ alembic.ini
‚îú‚îÄ‚îÄ amvera.yml
‚îú‚îÄ‚îÄ app
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ api
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ routes
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ bot_control.py
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ trade_log.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ config.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ indicators
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ market_grades.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ notifier.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ output.txt
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ save_all_files.sh
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ services
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ bot_controller.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ bot_runner.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ bybit_service.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ bybit_sync.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ coin_ranker.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ coin_rotator.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ coin_selector.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ model_trainer.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ trading_system.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ strategies
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ balance_snapshots.json
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ base.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ma_crossover.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ neural_network
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ model.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ trainer.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ neural_strategy.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ trader.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ trading
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ data_provider.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ order_executor.py
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ utils
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ candle_sync.py
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ coin_loader.py
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ get_history.py
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ get_profit.py
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ log_helper.py
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ place_order.py
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ symbol_selector.py
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ trading_utils.py
‚îú‚îÄ‚îÄ bot.db
‚îú‚îÄ‚îÄ bot_state.json
‚îú‚îÄ‚îÄ check_models.py
‚îú‚îÄ‚îÄ coins_list.txt
‚îú‚îÄ‚îÄ data
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ coin_ranking.json
‚îú‚îÄ‚îÄ get_balance_history.py
‚îú‚îÄ‚îÄ last_filled_orders_full.json
‚îú‚îÄ‚îÄ logs
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ bot_system.log
‚îú‚îÄ‚îÄ main.py
‚îú‚îÄ‚îÄ models
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ADA_neural_model.config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ADA_neural_model.keras
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ADA_neural_model_scaler.npz
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ALGO_neural_model.config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ALGO_neural_model.keras
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ALGO_neural_model_scaler.npz
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ APE_neural_model.config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ APE_neural_model.keras
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ APE_neural_model_scaler.npz
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ APT_neural_model.config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ APT_neural_model.keras
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ APT_neural_model_scaler.npz
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ARB_neural_model.config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ARB_neural_model.keras
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ARB_neural_model_scaler.npz
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ARKM_neural_model.config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ARKM_neural_model.keras
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ARKM_neural_model_scaler.npz
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ AVAX_neural_model.config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ AVAX_neural_model.keras
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ AVAX_neural_model_scaler.npz
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ BEAM_neural_model.config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ BEAM_neural_model.keras
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ BEAM_neural_model_scaler.npz
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ CHZ_neural_model.config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ CHZ_neural_model.keras
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ CHZ_neural_model_scaler.npz
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ DOGE_neural_model.config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ DOGE_neural_model.keras
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ DOGE_neural_model_scaler.npz
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ FET_neural_model.config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ FET_neural_model.keras
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ FET_neural_model_scaler.npz
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ GRT_neural_model.config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ GRT_neural_model.keras
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ GRT_neural_model_scaler.npz
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ HBAR_neural_model.config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ HBAR_neural_model.keras
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ HBAR_neural_model_scaler.npz
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ JASMY_neural_model.config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ JASMY_neural_model.keras
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ JASMY_neural_model_scaler.npz
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ KAIA_neural_model.config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ KAIA_neural_model.keras
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ KAIA_neural_model_scaler.npz
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ KAS_neural_model.config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ KAS_neural_model.keras
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ KAS_neural_model_scaler.npz
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ NEAR_neural_model.config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ NEAR_neural_model.keras
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ NEAR_neural_model_scaler.npz
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ OP_neural_model.config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ OP_neural_model.keras
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ OP_neural_model_scaler.npz
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ POL_neural_model.config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ POL_neural_model.keras
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ POL_neural_model_scaler.npz
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ PYTH_neural_model.config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ PYTH_neural_model.keras
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ PYTH_neural_model_scaler.npz
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ SAND_neural_model.config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ SAND_neural_model.keras
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ SAND_neural_model_scaler.npz
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ SOL_neural_model.config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ SOL_neural_model.keras
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ SOL_neural_model_scaler.npz
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ STX_neural_model.config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ STX_neural_model.keras
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ STX_neural_model_scaler.npz
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ SUI_neural_model.config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ SUI_neural_model.keras
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ SUI_neural_model_scaler.npz
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ TRX_neural_model.config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ TRX_neural_model.keras
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ TRX_neural_model_scaler.npz
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ WLD_neural_model.config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ WLD_neural_model.keras
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ WLD_neural_model_scaler.npz
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ XLM_neural_model.config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ XLM_neural_model.keras
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ XLM_neural_model_scaler.npz
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ XRP_neural_model.config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ XRP_neural_model.keras
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ XRP_neural_model_scaler.npz
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ZIG_neural_model.config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ZIG_neural_model.keras
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ZIG_neural_model_scaler.npz
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ZK_neural_model.config
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ZK_neural_model.keras
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ ZK_neural_model_scaler.npz
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ package-lock.json
‚îú‚îÄ‚îÄ pytest.ini
‚îú‚îÄ‚îÄ pytest.log
‚îú‚îÄ‚îÄ requirements_all.txt
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ run_bot.py
‚îú‚îÄ‚îÄ run_func.py
‚îú‚îÄ‚îÄ test_result.txt
‚îú‚îÄ‚îÄ tests
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ test_candels_requwst.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ test_coin_selector.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ test_coin_selector_real.py
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ test_model.py
‚îî‚îÄ‚îÄ tree.txt

14 directories, 156 files
